---
title: 播放器分析
date: 2017-02-27 14:36:49
tags:
---

#### 前言

这个播放器是基于B站的ijkplayer播放器进行裁剪和改编的，所以可以去下载ijkplayer的源码（ijkplayer播放器其实是基于ffplay进行改写的）。

#### 架构

![](http://okxoqauma.bkt.clouddn.com/%E6%92%AD%E6%94%BE%E5%99%A8%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E6%9E%B6%E6%9E%84%E5%9B%BE.png)

从上图可以看出，这个播放器主要是由三大模块组成，它们分别是音视频解码模块、音视频播放模块、音视频缓存模块。

##### 1.音视频缓存模块

音视频缓存主要由两部分组成，一部分是原始数据的缓存，另一部分是经过解码处理后的数据缓存。缓存的作用是用于形成一个异步的生产者消费者模型。下面将分别介绍这两部分。

###### 原始数据缓存

![](http://okxoqauma.bkt.clouddn.com/%E6%92%AD%E6%94%BE%E5%99%A8%E2%80%94%E2%80%94%E5%8E%9F%E5%A7%8B%E7%BC%93%E5%AD%98%E9%83%A8%E5%88%86%E5%9B%BE.png)

原始缓存部分由`PacketQueue`类和`MyAVPacketList`结构体构成，视频和音频的原始缓存都是这样的结构。

`PacketQueue`简单介绍一下`abort_request_`和`serial_`。其中`abort_request_`用于控制终止从缓存区取数据或者放入数据，比如当我们需要结束播放时，就需要将这个数据置为1。而`serial`不仅仅在`PacketQueue`类中会出现，其它很多类中也都会出现这个成员变量，该成员变量的主要作用是起标记作用，用于判断缓存中的数据是否需要清空丢弃或者其它的由于清空需要重新计算的数据。每当需要清空数据时，`PacketQueue`中的该变量会自增1，而如果队列中还有数据的话，那么队列中的数据也就是`MyAVPacketList`的`serial`将会是自增前的值，因此判断两者不相等，旧数据将会被丢弃而不会被解码。总之`serial`变量在整个播放器中主要用于判断数据是否过期，需要丢弃或重新计算的作用。

`MyAVPacketList`类中的`pkt`用于存储真正的原始数据，`next`用于指向下一个数据，从中可以看出这是一个链表结构，`serial`在每次数据被放入队列时都会被赋值为`PacketQueue`中的`serial_`的值。

###### 解码后的数据缓存

![](http://okxoqauma.bkt.clouddn.com/%E6%92%AD%E6%94%BE%E5%99%A8%E2%80%94%E2%80%94%E8%A7%A3%E7%A0%81%E5%90%8E%E7%9A%84%E7%BC%93%E5%AD%98%E9%83%A8%E5%88%86%E5%9B%BE.png)

解码后的数据缓存主要由`FrameQueue`和`Frame`组成。

`FrameQueue`其中几个成员变量：

- `queue_`，是一个`Frame`类型的数组，用于存储解码处理后的数据。
- `rindex_`，用于记录该从缓存哪个位置读取数据。
- `windex_`，用于记录该从缓存哪个位置放入新数据。

`FrameQueue`的几个重要成员函数如下：

- `FrameQueueWrite()`，用于获取相应`windex_`处的`Frame*`类型数据，方便把解码后的数据赋值其成员变量。
- `FrameQueuePush()`，将`windex_`索引加1，移动到下一个位置。
- `FrameQueuePeek()`，获取缓存中的数据用于播放。
- `FrameQueueNext()`，将`rindex_`索引加1，移动到下一个位置。

从这里可以看出这里的缓存用了享元模式。

`Frame`中的一些重要变量：

- `frame_`，用于存储解码后的音频数据（视频缓存时无用）。
- `bmp_`， 用于存储解码后并进行图像格式转换后视频数据(音频缓存时无用)。
- `pts_`，用于表示该帧的显示时间戳（在音视频同步中很重要的一个变量）。
- `serial_`，跟之前在原始数据缓存时介绍的作用一样，其值最终是来自于`MyAVPacketList`中的`serial`。
- `allocated_`， 用于判断当前`bmp_`是否已经有内存分配了（音频缓存时无用）。

##### 2.音视频解码模块

###### 解码部分

![](http://okxoqauma.bkt.clouddn.com/%E6%92%AD%E6%94%BE%E5%99%A8%E2%80%94%E2%80%94%E8%A7%A3%E7%A0%81%E9%83%A8%E5%88%86%E5%9B%BE.png)

音视频的解码主要由`Decoder`类完成，该类主要的成员变量：

- `avctx_`，这个是FFmpeg中用于解码的一个重要成员。
- `pkt_serial_`，这个是用于记录当前从原始缓存区解码出来的数据的`serial`，用于对比缓存队列的serial，如果两者不相等，则说明该数据需要丢弃，因为该数据属于需要清空的数据。
- `packet_pending_`，这个用于标记该次数据没有解析完，需要下次再进行解析。

最重要的成员函数就是`DecoderDecodeFrame()`函数了，调用该函数就能从原始数据缓存区中取出一个数据然后解码。音频和视频的解码都在这个函数中。

###### 视频格式转换部分

![](http://okxoqauma.bkt.clouddn.com/%E6%92%AD%E6%94%BE%E5%99%A8%E2%80%94%E2%80%94%E5%9B%BE%E5%83%8F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E9%83%A8%E5%88%86.png)

该部分主要的类就是`VoutOverlay`了，下面介绍一下其成员变量和成员函数：

成员变量：

- width_：这个宽度代表其图像转换后的宽度。
- height_：这个高度代表其图像转换后的高度。
- format_：这个代表图像最终格式。
- pitches_：用于记录图像格式转换后每一个维度的长度（YUV有三个维度，RGB只有一个）。
- pixels_：用于存储图像格式转换后图像本身的数据。

成员变量：

- `ImageConvert()`：该函数用于将原始图像格式转换成需要呈现在屏幕上的格式（其内部实现使用了libyuv）
- `FillFrame()`：该函数最终会调用`ImageConver()`函数，将解码出来的`AVFrame`数据最终转换成想要的图像格式存储在上述的`pixels_`中。

##### 3.音视频播放模块

###### 时钟部分

![](http://okxoqauma.bkt.clouddn.com/%E6%92%AD%E6%94%BE%E5%99%A8%E2%80%94%E2%80%94%E6%92%AD%E6%94%BE%E6%A8%A1%E5%9D%97%E4%B9%8B%E6%97%B6%E9%92%9F.png)

时钟部分就一个`Clock`类，该类用于记录当前视频或者音频播放的时间，主要介绍一下其成员变量：

- `pts_`：用于记录音频或者视频播放的时间，会通过设置时间函数，将视频帧或者音频帧上的显示时间戳赋值给`pts_`。
- `pts_drif`：用于记录`pts_`与当前系统时间的差值。
- `last_updated_`：记录当`Clock`类更新`pts_`时间时，当前的系统时间。

`Clock`类是音视频同步时很重要的一个类。

###### 视频播放部分

![](http://okxoqauma.bkt.clouddn.com/%E6%92%AD%E6%94%BE%E5%99%A8%E2%80%94%E2%80%94%E6%92%AD%E6%94%BE%E6%A8%A1%E5%9D%97%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E9%83%A8%E5%88%86.png)

在进行一串音视频同步处理后，最终会调用`Vout::DisplayOverlay()`函数来显示图像。`ANativeWindow`类型的数据是通过Java层传下来的Surface获取的。

###### 音频部分

![](http://okxoqauma.bkt.clouddn.com/%E6%92%AD%E6%94%BE%E5%99%A8%E2%80%94%E2%80%94%E6%92%AD%E6%94%BE%E6%A8%A1%E5%9D%97%E4%B9%8B%E9%9F%B3%E9%A2%91%E9%83%A8%E5%88%86.png)

音频播放部分主要由`Aout`、`Aout_Opaque`、`AndroidAudioTrack`三个类组成。`Aout_Opaque::buffer_`这个主要用于存储从解码后的缓存区数据中获取的音频数据。下面重点介绍`AndroidAudioTrack`类。

`AndroidAudioTrack`的成员变量：

- thiz_：该变量用于存储在Native层创建的Java层的`AudioTrack`类的对象。
- byte_buffer_：用于存储经过JNI转化后的音频数据。

`AndroidAudioTrack`的成员函数：

- `AndroidAudioTrackWrite()：该函数最终会通过JNI调用Java层的`AudioTrack`对象播放声音。
- `AndroidAudioTrackFree()`：最终通过JNI调用释放`AudioTrack`对象。


#### 时序图

##### 视频渲染

![渲染时序图](http://okxoqauma.bkt.clouddn.com/%E6%92%AD%E6%94%BE%E5%99%A8%E2%80%94%E2%80%94%E6%B8%B2%E6%9F%93%E9%83%A8%E5%88%86%E6%97%B6%E5%BA%8F%E5%9B%BE.png)

该时序图主要展示了从`JNI`调用相关函数直到创建`VideoRefreshThread`线程的过程，以及`VideoRefreshThread`线程内部不断循环刷新视频的过程。

##### 视频解码

##### ![解码时序图](http://okxoqauma.bkt.clouddn.com/%E6%92%AD%E6%94%BE%E5%99%A8%E2%80%94%E2%80%94%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E6%97%B6%E5%BA%8F%E5%9B%BE.png)

该时序图展示了`VideoThread`线程的创建过程，以及`VideoThread`线程内部解码、图像格式转换和读写缓存区的过程。音频解码的过程类似，这里就不画出其时序图了。   

##### 音频播放

![](http://okxoqauma.bkt.clouddn.com/%E6%92%AD%E6%94%BE%E5%99%A8%E2%80%94%E2%80%94%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE%E6%97%B6%E5%BA%8F%E5%9B%BE.png)

该时序图展示了`AoutThread`线程的创建过程，以及`AoutThread`线程内部通过`AudioCallback()`函数获取音频数据，然后最终通过JNI调用Java层的`AudioTrack`对象播放音频数据的大致流程。 

#### 总结

整个播放器大致就是通过生产者和消费者模型来完成音视频数据的解析和最终播放的，并且通过时间戳来完成音视频的同步。