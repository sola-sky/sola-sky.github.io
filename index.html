<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="学习记录和总结">
<meta property="og:type" content="website">
<meta property="og:title" content="Li's Blog">
<meta property="og:url" content="http://solasky.info/index.html">
<meta property="og:site_name" content="Li's Blog">
<meta property="og:description" content="学习记录和总结">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Li's Blog">
<meta name="twitter:description" content="学习记录和总结">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://solasky.info/"/>





  <title> Li's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Li's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://solasky.info/2017/02/27/播放器分析/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="sola_sky">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://imgsrc.baidu.com/forum/w%3D580/sign=209cc278b019ebc4c0787691b227cf79/9ec6b93eb13533fadb266e33abd3fd1f41345b3d.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Li's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Li's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/27/播放器分析/" itemprop="url">
                  播放器分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-27T14:36:49+08:00">
                2017-02-27
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>这个播放器是基于B站的ijkplayer播放器进行裁剪和改编的，所以可以去下载ijkplayer的源码（ijkplayer播放器其实是基于ffplay进行改写的）。</p>
<h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p><img src="http://okxoqauma.bkt.clouddn.com/%E6%92%AD%E6%94%BE%E5%99%A8%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt=""></p>
<p>从上图可以看出，这个播放器主要是由三大模块组成，它们分别是音视频解码模块、音视频播放模块、音视频缓存模块。</p>
<h5 id="1-音视频缓存模块"><a href="#1-音视频缓存模块" class="headerlink" title="1.音视频缓存模块"></a>1.音视频缓存模块</h5><p>音视频缓存主要由两部分组成，一部分是原始数据的缓存，另一部分是经过解码处理后的数据缓存。缓存的作用是用于形成一个异步的生产者消费者模型。下面将分别介绍这两部分。</p>
<h6 id="原始数据缓存"><a href="#原始数据缓存" class="headerlink" title="原始数据缓存"></a>原始数据缓存</h6><p><img src="http://okxoqauma.bkt.clouddn.com/%E6%92%AD%E6%94%BE%E5%99%A8%E2%80%94%E2%80%94%E5%8E%9F%E5%A7%8B%E7%BC%93%E5%AD%98%E9%83%A8%E5%88%86%E5%9B%BE.png" alt=""></p>
<p>原始缓存部分由<code>PacketQueue</code>类和<code>MyAVPacketList</code>结构体构成，视频和音频的原始缓存都是这样的结构。</p>
<p><code>PacketQueue</code>简单介绍一下<code>abort_request_</code>和<code>serial_</code>。其中<code>abort_request_</code>用于控制终止从缓存区取数据或者放入数据，比如当我们需要结束播放时，就需要将这个数据置为1。而<code>serial</code>不仅仅在<code>PacketQueue</code>类中会出现，其它很多类中也都会出现这个成员变量，该成员变量的主要作用是起标记作用，用于判断缓存中的数据是否需要清空丢弃或者其它的由于清空需要重新计算的数据。每当需要清空数据时，<code>PacketQueue</code>中的该变量会自增1，而如果队列中还有数据的话，那么队列中的数据也就是<code>MyAVPacketList</code>的<code>serial</code>将会是自增前的值，因此判断两者不相等，旧数据将会被丢弃而不会被解码。总之<code>serial</code>变量在整个播放器中主要用于判断数据是否过期，需要丢弃或重新计算的作用。</p>
<p><code>MyAVPacketList</code>类中的<code>pkt</code>用于存储真正的原始数据，<code>next</code>用于指向下一个数据，从中可以看出这是一个链表结构，<code>serial</code>在每次数据被放入队列时都会被赋值为<code>PacketQueue</code>中的<code>serial_</code>的值。</p>
<h6 id="解码后的数据缓存"><a href="#解码后的数据缓存" class="headerlink" title="解码后的数据缓存"></a>解码后的数据缓存</h6><p><img src="http://okxoqauma.bkt.clouddn.com/%E6%92%AD%E6%94%BE%E5%99%A8%E2%80%94%E2%80%94%E8%A7%A3%E7%A0%81%E5%90%8E%E7%9A%84%E7%BC%93%E5%AD%98%E9%83%A8%E5%88%86%E5%9B%BE.png" alt=""></p>
<p>解码后的数据缓存主要由<code>FrameQueue</code>和<code>Frame</code>组成。</p>
<p><code>FrameQueue</code>其中几个成员变量：</p>
<ul>
<li><code>queue_</code>，是一个<code>Frame</code>类型的数组，用于存储解码处理后的数据。</li>
<li><code>rindex_</code>，用于记录该从缓存哪个位置读取数据。</li>
<li><code>windex_</code>，用于记录该从缓存哪个位置放入新数据。</li>
</ul>
<p><code>FrameQueue</code>的几个重要成员函数如下：</p>
<ul>
<li><code>FrameQueueWrite()</code>，用于获取相应<code>windex_</code>处的<code>Frame*</code>类型数据，方便把解码后的数据赋值其成员变量。</li>
<li><code>FrameQueuePush()</code>，将<code>windex_</code>索引加1，移动到下一个位置。</li>
<li><code>FrameQueuePeek()</code>，获取缓存中的数据用于播放。</li>
<li><code>FrameQueueNext()</code>，将<code>rindex_</code>索引加1，移动到下一个位置。</li>
</ul>
<p>从这里可以看出这里的缓存用了享元模式。</p>
<p><code>Frame</code>中的一些重要变量：</p>
<ul>
<li><code>frame_</code>，用于存储解码后的音频数据（视频缓存时无用）。</li>
<li><code>bmp_</code>， 用于存储解码后并进行图像格式转换后视频数据(音频缓存时无用)。</li>
<li><code>pts_</code>，用于表示该帧的显示时间戳（在音视频同步中很重要的一个变量）。</li>
<li><code>serial_</code>，跟之前在原始数据缓存时介绍的作用一样，其值最终是来自于<code>MyAVPacketList</code>中的<code>serial</code>。</li>
<li><code>allocated_</code>， 用于判断当前<code>bmp_</code>是否已经有内存分配了（音频缓存时无用）。</li>
</ul>
<h5 id="2-音视频解码模块"><a href="#2-音视频解码模块" class="headerlink" title="2.音视频解码模块"></a>2.音视频解码模块</h5><h6 id="解码部分"><a href="#解码部分" class="headerlink" title="解码部分"></a>解码部分</h6><p><img src="http://okxoqauma.bkt.clouddn.com/%E6%92%AD%E6%94%BE%E5%99%A8%E2%80%94%E2%80%94%E8%A7%A3%E7%A0%81%E9%83%A8%E5%88%86%E5%9B%BE.png" alt=""></p>
<p>音视频的解码主要由<code>Decoder</code>类完成，该类主要的成员变量：</p>
<ul>
<li><code>avctx_</code>，这个是FFmpeg中用于解码的一个重要成员。</li>
<li><code>pkt_serial_</code>，这个是用于记录当前从原始缓存区解码出来的数据的<code>serial</code>，用于对比缓存队列的serial，如果两者不相等，则说明该数据需要丢弃，因为该数据属于需要清空的数据。</li>
<li><code>packet_pending_</code>，这个用于标记该次数据没有解析完，需要下次再进行解析。</li>
</ul>
<p>最重要的成员函数就是<code>DecoderDecodeFrame()</code>函数了，调用该函数就能从原始数据缓存区中取出一个数据然后解码。音频和视频的解码都在这个函数中。</p>
<h6 id="视频格式转换部分"><a href="#视频格式转换部分" class="headerlink" title="视频格式转换部分"></a>视频格式转换部分</h6><p><img src="http://okxoqauma.bkt.clouddn.com/%E6%92%AD%E6%94%BE%E5%99%A8%E2%80%94%E2%80%94%E5%9B%BE%E5%83%8F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E9%83%A8%E5%88%86.png" alt=""></p>
<p>该部分主要的类就是<code>VoutOverlay</code>了，下面介绍一下其成员变量和成员函数：</p>
<p>成员变量：</p>
<ul>
<li>width_：这个宽度代表其图像转换后的宽度。</li>
<li>height_：这个高度代表其图像转换后的高度。</li>
<li>format_：这个代表图像最终格式。</li>
<li>pitches_：用于记录图像格式转换后每一个维度的长度（YUV有三个维度，RGB只有一个）。</li>
<li>pixels_：用于存储图像格式转换后图像本身的数据。</li>
</ul>
<p>成员变量：</p>
<ul>
<li><code>ImageConvert()</code>：该函数用于将原始图像格式转换成需要呈现在屏幕上的格式（其内部实现使用了libyuv）</li>
<li><code>FillFrame()</code>：该函数最终会调用<code>ImageConver()</code>函数，将解码出来的<code>AVFrame</code>数据最终转换成想要的图像格式存储在上述的<code>pixels_</code>中。</li>
</ul>
<h5 id="3-音视频播放模块"><a href="#3-音视频播放模块" class="headerlink" title="3.音视频播放模块"></a>3.音视频播放模块</h5><h6 id="时钟部分"><a href="#时钟部分" class="headerlink" title="时钟部分"></a>时钟部分</h6><p><img src="http://okxoqauma.bkt.clouddn.com/%E6%92%AD%E6%94%BE%E5%99%A8%E2%80%94%E2%80%94%E6%92%AD%E6%94%BE%E6%A8%A1%E5%9D%97%E4%B9%8B%E6%97%B6%E9%92%9F.png" alt=""></p>
<p>时钟部分就一个<code>Clock</code>类，该类用于记录当前视频或者音频播放的时间，主要介绍一下其成员变量：</p>
<ul>
<li><code>pts_</code>：用于记录音频或者视频播放的时间，会通过设置时间函数，将视频帧或者音频帧上的显示时间戳赋值给<code>pts_</code>。</li>
<li><code>pts_drif</code>：用于记录<code>pts_</code>与当前系统时间的差值。</li>
<li><code>last_updated_</code>：记录当<code>Clock</code>类更新<code>pts_</code>时间时，当前的系统时间。</li>
</ul>
<p><code>Clock</code>类是音视频同步时很重要的一个类。</p>
<h6 id="视频播放部分"><a href="#视频播放部分" class="headerlink" title="视频播放部分"></a>视频播放部分</h6><p><img src="http://okxoqauma.bkt.clouddn.com/%E6%92%AD%E6%94%BE%E5%99%A8%E2%80%94%E2%80%94%E6%92%AD%E6%94%BE%E6%A8%A1%E5%9D%97%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E9%83%A8%E5%88%86.png" alt=""></p>
<p>在进行一串音视频同步处理后，最终会调用<code>Vout::DisplayOverlay()</code>函数来显示图像。<code>ANativeWindow</code>类型的数据是通过Java层传下来的Surface获取的。</p>
<h6 id="音频部分"><a href="#音频部分" class="headerlink" title="音频部分"></a>音频部分</h6><p><img src="http://okxoqauma.bkt.clouddn.com/%E6%92%AD%E6%94%BE%E5%99%A8%E2%80%94%E2%80%94%E6%92%AD%E6%94%BE%E6%A8%A1%E5%9D%97%E4%B9%8B%E9%9F%B3%E9%A2%91%E9%83%A8%E5%88%86.png" alt=""></p>
<p>音频播放部分主要由<code>Aout</code>、<code>Aout_Opaque</code>、<code>AndroidAudioTrack</code>三个类组成。<code>Aout_Opaque::buffer_</code>这个主要用于存储从解码后的缓存区数据中获取的音频数据。下面重点介绍<code>AndroidAudioTrack</code>类。</p>
<p><code>AndroidAudioTrack</code>的成员变量：</p>
<ul>
<li>thiz_：该变量用于存储在Native层创建的Java层的<code>AudioTrack</code>类的对象。</li>
<li>byte<em>buffer</em>：用于存储经过JNI转化后的音频数据。</li>
</ul>
<p><code>AndroidAudioTrack</code>的成员函数：</p>
<ul>
<li><code>AndroidAudioTrackWrite()：该函数最终会通过JNI调用Java层的</code>AudioTrack`对象播放声音。</li>
<li><code>AndroidAudioTrackFree()</code>：最终通过JNI调用释放<code>AudioTrack</code>对象。</li>
</ul>
<h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><h5 id="视频渲染"><a href="#视频渲染" class="headerlink" title="视频渲染"></a>视频渲染</h5><p><img src="http://okxoqauma.bkt.clouddn.com/%E6%92%AD%E6%94%BE%E5%99%A8%E2%80%94%E2%80%94%E6%B8%B2%E6%9F%93%E9%83%A8%E5%88%86%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="渲染时序图"></p>
<p>该时序图主要展示了从<code>JNI</code>调用相关函数直到创建<code>VideoRefreshThread</code>线程的过程，以及<code>VideoRefreshThread</code>线程内部不断循环刷新视频的过程。</p>
<h5 id="视频解码"><a href="#视频解码" class="headerlink" title="视频解码"></a>视频解码</h5><h5 id=""><a href="#" class="headerlink" title=""></a><img src="http://okxoqauma.bkt.clouddn.com/%E6%92%AD%E6%94%BE%E5%99%A8%E2%80%94%E2%80%94%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="解码时序图"></h5><p>该时序图展示了<code>VideoThread</code>线程的创建过程，以及<code>VideoThread</code>线程内部解码、图像格式转换和读写缓存区的过程。音频解码的过程类似，这里就不画出其时序图了。   </p>
<h5 id="音频播放"><a href="#音频播放" class="headerlink" title="音频播放"></a>音频播放</h5><p><img src="http://okxoqauma.bkt.clouddn.com/%E6%92%AD%E6%94%BE%E5%99%A8%E2%80%94%E2%80%94%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt=""></p>
<p>该时序图展示了<code>AoutThread</code>线程的创建过程，以及<code>AoutThread</code>线程内部通过<code>AudioCallback()</code>函数获取音频数据，然后最终通过JNI调用Java层的<code>AudioTrack</code>对象播放音频数据的大致流程。 </p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>整个播放器大致就是通过生产者和消费者模型来完成音视频数据的解析和最终播放的，并且通过时间戳来完成音视频的同步。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://solasky.info/2017/02/08/音视频的控制/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="sola_sky">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://imgsrc.baidu.com/forum/w%3D580/sign=209cc278b019ebc4c0787691b227cf79/9ec6b93eb13533fadb266e33abd3fd1f41345b3d.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Li's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Li's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/08/音视频的控制/" itemprop="url">
                  音视频的控制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-08T10:02:19+08:00">
                2017-02-08
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://solasky.info/2017/02/07/优化视频解码渲染/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="sola_sky">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://imgsrc.baidu.com/forum/w%3D580/sign=209cc278b019ebc4c0787691b227cf79/9ec6b93eb13533fadb266e33abd3fd1f41345b3d.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Li's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Li's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/07/优化视频解码渲染/" itemprop="url">
                  优化视频解码渲染
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-07T09:05:35+08:00">
                2017-02-07
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="问题的出现"><a href="#问题的出现" class="headerlink" title="问题的出现"></a>问题的出现</h2><p>在项目中出现 了一个问题就android在使用ffmpeg进行视频的解码渲染的过程中耗时非常的严重，导致的直接现象就是视频播放过程中就像是慢动作回放一样，完全无法满足需求。而反观同事的ios却不会，观其代码，发现其调用ffmpeg的代码跟我这边是差不多的（都是参考网上的代码）。后来即使使用了高配的android手机，发现其效果还是无法满足需求。最后去看开源的ijkplayer，看其是怎么解决的。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>在研究ijkplayer的源码过程中找到了解决方案（只针对FFmpeg、ANativeWindow，并且没有使用OpenGL）：</p>
<ul>
<li>优先采用的是libyuv来进行视频的格式转换的，当无法转换时再采用ffmpeg的<code>sws_scale()</code>进行转化。而且发现这种方案在ijkplayer源码中只是针对android平台，而苹果的直接是使用ffmpeg的<code>sws_sclae()</code>方法，不需要使用libyuv，至于为什么苹果不需要没有去深究，效率肯定是够了。</li>
<li>长宽进行针对不同格式进行对齐操作，不过这块倒是没有去测试过到底快了多少。</li>
<li>原先在进行缩放的时候也使用了libyuv对视频进行缩放，将视频长宽缩放到传进来的Surface的长宽，但是实际发现不需要这样做，<code>ANativeWindow_setBuffersGeomerty()</code>这个函数会将尺寸自动缩放到窗口实际的物理尺寸。这样就省了libyuv进行缩放操作的时间了</li>
<li>还有一个就是进行音视频同步，因为部分帧会解码快、部分比较耗时，通过音视频同步可以控制刷新的快慢或者直接丢帧。</li>
<li>通过多线程的方式，一个线程用于解码格式转换，一个线程用于专门的刷新操作，这样的并行操作相比于串行操作来会缩短一些时间</li>
</ul>
<p>接下来，看看具体的代码：</p>
<h3 id="1-使用libyuv替换ffmpeg的sws-scale"><a href="#1-使用libyuv替换ffmpeg的sws-scale" class="headerlink" title="1. 使用libyuv替换ffmpeg的sws_scale"></a>1. 使用libyuv替换ffmpeg的<code>sws_scale</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> VoutOverlay::ImageConvert(<span class="keyword">int</span> width, <span class="keyword">int</span> height, AVPixelFormat dst_format, <span class="keyword">uint8_t</span> **dst_data,</div><div class="line">                               <span class="keyword">int</span> *dst_linesize, AVPixelFormat src_format, <span class="keyword">uint8_t</span> **src_data,</div><div class="line">                               <span class="keyword">const</span> <span class="keyword">int</span> *src_linesize) &#123;</div><div class="line">    <span class="keyword">if</span> (AV_PIX_FMT_YUV420P == src_format) &#123;</div><div class="line">        <span class="keyword">if</span> (AV_PIX_FMT_RGB565 == dst_format) &#123;</div><div class="line">            <span class="keyword">return</span> libyuv::I420ToRGB565(src_data[<span class="number">0</span>], src_linesize[<span class="number">0</span>],</div><div class="line">                                        src_data[<span class="number">1</span>], src_linesize[<span class="number">1</span>],</div><div class="line">                                        src_data[<span class="number">2</span>], src_linesize[<span class="number">2</span>],</div><div class="line">                                        dst_data[<span class="number">0</span>], dst_linesize[<span class="number">0</span>],</div><div class="line">                                        width, height);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AV_PIX_FMT_0BGR32) &#123;</div><div class="line">            <span class="keyword">return</span> libyuv::I420ToABGR(src_data[<span class="number">0</span>], src_linesize[<span class="number">0</span>],</div><div class="line">                                      src_data[<span class="number">1</span>], src_linesize[<span class="number">1</span>],</div><div class="line">                                      src_data[<span class="number">2</span>], src_linesize[<span class="number">2</span>],</div><div class="line">                                      dst_data[<span class="number">0</span>], dst_linesize[<span class="number">0</span>],</div><div class="line">                                      width, height);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为P2P端传过来的视频是YUV420P的格式，这里也只简单判断进行YUV420P转其他格式，这里也是参考ijkplayer写的。这里解释一下libyuv的参数的意思，<code>I420ToRGB565()</code>中的第一参数<code>src_data[0]</code>代表Y分量，<code>src_linesize[0]</code>代表Y分量的长度，剩下的分别代表U、V分量，而最终转化成RGB565时图像数据是放在一个数组进行存储的，所以只需要<code>dst_data[0]</code>一个数组就行。详细内容可以上网搜索一下YUV和RGB资料。</p>
<h3 id="2-对长宽进行对齐操作"><a href="#2-对长宽进行对齐操作" class="headerlink" title="2. 对长宽进行对齐操作"></a>2. 对长宽进行对齐操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">VoutOverlay::VoutOverlay(<span class="keyword">int</span> width, <span class="keyword">int</span> height, AVPixelFormat frame_format) : width_(width), height_(height), format_(frame_format) &#123;</div><div class="line">    opaque_ = <span class="keyword">new</span> VoutOverlayOpaque();</div><div class="line">    pitches_ = opaque_-&gt;pitches();</div><div class="line">    pixels_ = opaque_-&gt;pixels();</div><div class="line">  </div><div class="line">    ··· ··· </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (AV_PIX_FMT_RGB565 == frame_format) &#123;</div><div class="line">        buf_width = ALIGN(width, <span class="number">8</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AV_PIX_FMT_RGBA == frame_format) &#123;</div><div class="line">        buf_width = ALIGN(width, <span class="number">4</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        buf_width = ALIGN(width, <span class="number">16</span>)；</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ··· ···</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据ijkplayer上的提示是<strong>16 bytes align pitch for arm-neon image-convert</strong>，所以最终用于存储转化的视频图像的字节数是16的倍数，因此需要对缓存的宽度进行调整。比如当最终转化为RGB565时，宽度需要是8的倍数，因为RGB565格式是每个像素占用2个字节，所以宽度调整为8的倍数时就能保证最终图像的字节数是16的倍数（n <em> 8 </em> 2 == n <em> 16）。又比如为RGBA时，每个像素占用4字节，所以调整宽度为4的倍数，这样就能确保最终图像是16的倍数（n </em> 4 <em> 4 = n </em> 16）。</p>
<h3 id="3-使用ANativeWindow-setBuffersGeomerty-直接进行缩放"><a href="#3-使用ANativeWindow-setBuffersGeomerty-直接进行缩放" class="headerlink" title="3. 使用ANativeWindow_setBuffersGeomerty()直接进行缩放"></a>3. 使用<code>ANativeWindow_setBuffersGeomerty()</code>直接进行缩放</h3><p>我原来是将视频图像格式YUV420P转化成RGB565后，再次利用libyuv对其进行缩放，以符合Surface的长宽，后面发现ANativeWindow_setBuffersGeometry()本身就有这个功能，不需要用到libyuv。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Change the format and size of the window buffers.</div><div class="line"> *</div><div class="line"> * The width and height control the number of pixels in the buffers, not the</div><div class="line"> * dimensions of the window on screen.  If these are different than the</div><div class="line"> * window's physical size, then it buffer will be scaled to match that size</div><div class="line"> * when compositing it to the screen.</div><div class="line"> *</div><div class="line"> * For all of these parameters, if 0 is supplied then the window's base</div><div class="line"> * value will come back in force.</div><div class="line"> *</div><div class="line"> * width and height must be either both zero or both non-zero.</div><div class="line"> *</div><div class="line"> */</div><div class="line">ANativeWindow_setBuffersGeometry(native_window_, buff_w, buff_h, WINDOW_FORMAT_RGB_565);</div></pre></td></tr></table></figure>
<h3 id="4-音视频同步"><a href="#4-音视频同步" class="headerlink" title="4. 音视频同步"></a>4. 音视频同步</h3><p>音视频同步，其本质是通过比较时间来控制视频的刷新频率，由于某帧导致视频整体慢了，那就缩短后面的视频帧的刷新时间间隔，以此弥补之前的耗时。<a href="http://solasky.info/2017/02/06/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF/">音视频同步可以看之前写的一篇文章</a>。</p>
<h3 id="5-多线程操作"><a href="#5-多线程操作" class="headerlink" title="5. 多线程操作"></a>5. 多线程操作</h3><h4 id="解码和格式转化线程："><a href="#解码和格式转化线程：" class="headerlink" title="解码和格式转化线程："></a>解码和格式转化线程：</h4><p><img src="http://okxoqauma.bkt.clouddn.com/%E4%BC%98%E5%8C%96%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E6%B8%B2%E6%9F%93%E2%80%94%E2%80%94%E8%A7%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E8%BD%AC%E5%8C%96.png" alt=""></p>
<p>在一个线程中不断循环执行这一步，不断的获取图片存放于缓存队列中。</p>
<p>具体的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">for</span> (;;) &#123;</div><div class="line">      ret = is-&gt;GetVideoFrame(ffp, frame); <span class="comment">// 从AVPacket队列中取一个AVPacket，然后解析到frame中</span></div><div class="line">      <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">          av_frame_free(&amp;frame);</div><div class="line">          <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (!ret) &#123;</div><div class="line">          <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">··· ··· </div><div class="line">      ret = is-&gt;QueuePicture(ffp, frame, pts, duration, av_frame_get_pkt_pos(frame),</div><div class="line">                             is-&gt;pviddec()-&gt;pkt_serial()); <span class="comment">// 将frame转化成预期的格式，然后存入图片队列中</span></div><div class="line">      av_frame_unref(frame);</div><div class="line">      <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h4 id="视频渲染线程："><a href="#视频渲染线程：" class="headerlink" title="视频渲染线程："></a>视频渲染线程：</h4><p><img src="http://okxoqauma.bkt.clouddn.com/%E4%BC%98%E5%8C%96%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E6%B8%B2%E6%9F%93%E2%80%94%E2%80%94%E6%B8%B2%E6%9F%93%E9%83%A8%E5%88%86.png" alt=""></p>
<p>视频渲染线程就是不断从图片缓存队列中提取数据，然后根据调整好的时间间隔进行渲染。</p>
<p>具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span>* FFPlayer::VideoRefreshThread(<span class="keyword">void</span> *arg) &#123;</div><div class="line">    assert(arg);</div><div class="line">    FFPlayer *player = (FFPlayer *) arg;</div><div class="line">    VideoState *is = player-&gt;is();</div><div class="line">    <span class="keyword">double</span> remaining_time = <span class="number">0.0</span>;</div><div class="line">    <span class="keyword">while</span> (!is-&gt;abort_request()) &#123;</div><div class="line">        <span class="keyword">if</span> (remaining_time &gt; <span class="number">0.0</span>) &#123;</div><div class="line">            av_usleep((<span class="keyword">int</span>)(<span class="keyword">int64_t</span>)(remaining_time * <span class="number">1000000.0</span>)); <span class="comment">// 根据调整的时间间隔睡眠一段时间</span></div><div class="line">        &#125;</div><div class="line">        remaining_time = <span class="number">0.01</span>;</div><div class="line">        <span class="keyword">if</span> (is-&gt;show_mode() == SHOW_MODE_VIDEO &amp;&amp; (!is-&gt;paused() || is-&gt;force_refresh())) &#123;</div><div class="line">            is-&gt;VideoRefresh(player, &amp;remaining_time);  <span class="comment">// VideoRefresh()函数会做出一些操作，包括计算延迟，是否丢帧以及是否刷新等。</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>VidoeRefresh()</code>函数的相关可以查看之前的一篇文章——<a href="http://solasky.info/2017/02/06/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF/">音视频同步技术</a>。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>性能优化这块还可以采用硬编码的形式，不过目前没有去研究；还有可以通过OpenGL来实现，我看ijkplayer上就优先有这种方案。后期可以继续学习ijkplayer的源码，还可以去看看vlc的源码。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://solasky.info/2017/02/06/音视频同步技术/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="sola_sky">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://imgsrc.baidu.com/forum/w%3D580/sign=209cc278b019ebc4c0787691b227cf79/9ec6b93eb13533fadb266e33abd3fd1f41345b3d.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Li's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Li's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/06/音视频同步技术/" itemprop="url">
                  音视频同步技术
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-06T08:45:24+08:00">
                2017-02-06
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-问题的产生"><a href="#1-问题的产生" class="headerlink" title="1.问题的产生"></a>1.问题的产生</h2><p>在项目中遇到的一个问题就是音视频不同步，直接的现象是：在回放车辆上的视频时出现了，离视频结束还有一段时间时只有画面没有声音了。导致这个问题的根本原因就是音视频不同步，原先做这块没有经验，视频只管视频自己，音频只管音频自己，而视频解析和渲染的过程中有些帧很耗时，导致了视频时间线上慢慢与音频时间线差距变大，最终出现音频播放了视频还有一段没有播。因此很有必要实行音视频同步。</p>
<h2 id="2-时间戳同步"><a href="#2-时间戳同步" class="headerlink" title="2. 时间戳同步"></a>2. 时间戳同步</h2><p>上网查找了音视频同步的解决方案后，决定采取时间戳的方式进行同步，这其中就要涉及PTS和DTS了，还会涉及到I、P、B帧等概念，具体的概念自己上网查找。</p>
<p>而采用时间戳同步时主要有三种：</p>
<ul>
<li>视频同步到音频时钟</li>
<li>音频同步到视频时钟</li>
<li>音视频同步到外部时钟</li>
</ul>
<p>项目中最终采用视频同步到音频时间的方案，因为人对于声音的分辨要高于视频的分辨，如果对声音进行处理很大概率会引起在观看过程中的不舒适。</p>
<h3 id="1-抽象层次上的音视频同步算法"><a href="#1-抽象层次上的音视频同步算法" class="headerlink" title="1. 抽象层次上的音视频同步算法"></a>1. 抽象层次上的音视频同步算法</h3><p>音频部分：</p>
<p><img src="http://okxoqauma.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5%E2%80%94%E2%80%94%E9%9F%B3%E9%A2%91%E9%83%A8%E5%88%86.png" alt=""></p>
<p>视频部分：</p>
<p><img src="http://okxoqauma.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5%E2%80%94%E2%80%94%E8%A7%86%E9%A2%91%E9%83%A8%E5%88%86.png" alt=""></p>
<p>总结：</p>
<p>视频同步到音频时，主要对比两者的时间钟，然后计算出视频应该延迟多长时间播放，再计算视频当前帧应该播放的时间点跟系统当前时间的情况，如果还未到播放时间点则延迟，如果已经到了播放时间点则播放，如果已经远远落后了则丢掉该帧。</p>
<h3 id="2-具体的音视频同步"><a href="#2-具体的音视频同步" class="headerlink" title="2. 具体的音视频同步"></a>2. 具体的音视频同步</h3><p>既然要对比音频和视频各自播放的时间，那么就需要记录当前音频和视频播放的时间戳</p>
<p><img src="http://okxoqauma.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5%E2%80%94%E2%80%94%E6%97%B6%E9%92%9F%E7%B1%BB.png" alt=""></p>
<p>这里只列出了一部分成员和操作，其中<code>pts_</code>用于记录当前播放到的视频或者音频本身对应帧的时间戳，<code>GetClock()</code>用于获取时间戳，而<code>SetClock()</code>用于设置时间戳（每播放一帧后都会重新设置相应的时间戳）。</p>
<p>接下来我们看看具体的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">void</span> VideoState::VideoRefresh(FFPlayer *player, <span class="keyword">double</span> *remaining_time) &#123;</div><div class="line">       	<span class="keyword">double</span> time; <span class="comment">//用于记录系统时间</span></div><div class="line">··· ···</div><div class="line">   </div><div class="line">        <span class="keyword">double</span> last_duration, duration, delay;</div><div class="line">        Frame *vp, *lastvp; <span class="comment">// lastvp代表上一帧，vp代表即将要显示的这一帧</span></div><div class="line"></div><div class="line">        lastvp = pictq_-&gt;FrameQueuePeekLast(); <span class="comment">//从缓存中获取上一帧</span></div><div class="line">        vp = pictq_-&gt;FrameQueuePeek(); <span class="comment">//从缓存中获取即将要显示的这一帧</span></div><div class="line">        ··· ···</div><div class="line"></div><div class="line">        last_duration = FrameDuration(lastvp, vp);  <span class="comment">//计算两视频帧间的间隔</span></div><div class="line">        delay = ComputeTargetDelay(last_duration); <span class="comment">//根据视频时间钟与音频时间钟之间的差值，调节需要延迟的时间</span></div><div class="line"></div><div class="line">        time = av_gettime_relative() / <span class="number">1000000.0</span>; <span class="comment">//获取系统当前时间</span></div><div class="line">··· ··· </div><div class="line">        </div><div class="line">        <span class="comment">// frame_timer_ 会一直累加播放过程中我们计算的时延，这里相当于上一次刷新视频帧的时间</span></div><div class="line">        <span class="comment">// 于是这里frame_timer_ + delay表示的是这一帧视频应该刷新的时间点</span></div><div class="line">        <span class="keyword">if</span> (time &lt; frame_timer_ + delay) &#123; </div><div class="line">            <span class="comment">// 代表当前系统时间还未到这一帧视频的刷新时间，于是计算需要休眠的时间以便等到刷新时间点的到来</span></div><div class="line">            *remaining_time = FFMIN(frame_timer_ + delay - time, *remaining_time);</div><div class="line">            <span class="keyword">goto</span> display;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        frame_timer_ += delay; <span class="comment">// frame_timer_ 累加时延</span></div><div class="line">   </div><div class="line">   		··· ···</div><div class="line"></div><div class="line">        pthread_mutex_lock(pictq_-&gt;mutex());</div><div class="line">        <span class="keyword">if</span> (!isnan(vp-&gt;pts_)) &#123;</div><div class="line">            UpdateVideoPts(vp-&gt;pts_, vp-&gt;pos_, vp-&gt;serial_); <span class="comment">// 这里最终调用上文提到的Clock类中的设置时间戳函数，用来更新最新一帧视频播放时对应的PTS</span></div><div class="line">        &#125;</div><div class="line">        pthread_mutex_unlock(pictq_-&gt;mutex());</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (pictq_-&gt;FrameQueueNbRemaining() &gt; <span class="number">1</span>) &#123; <span class="comment">// 如果视频缓存中还有下一帧视频</span></div><div class="line">            Frame *nextvp = pictq_-&gt;FrameQueuePeekNext(); <span class="comment">// 提取下一帧视频</span></div><div class="line">            duration = FrameDuration(vp, nextvp); </div><div class="line">            <span class="keyword">if</span> (!step_</div><div class="line">                &amp;&amp; (player-&gt;framedrop() &gt; <span class="number">0</span> ||</div><div class="line">                    (player-&gt;framedrop() &amp;&amp; GetMasterSyncType() != AV_SYNC_VIDEO_MASTER))</div><div class="line">                &amp;&amp; time &gt; frame_timer_ + duration) &#123; <span class="comment">//这里主要看 time &gt; frame_timer_ + duration这个判断就行，这里代表意思是如果下一帧视频渲染的时间点都比当前系统时间慢，也就是说视频已经慢了起码2帧了，那么就直接把当前帧丢掉不进行渲染，以此加快播放速度</span></div><div class="line">                frame_drops_late_++;</div><div class="line">                pictq_-&gt;FrameQueueNext(); <span class="comment">// 缓存移到下一帧</span></div><div class="line">                <span class="keyword">goto</span> retry; <span class="comment">// 重新进行渲染判断</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">   </div><div class="line">   ··· ··· </div><div class="line">   ··· ···</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这段代码已经注释的很详细了，接下来我们看看其中调用到的<code>ComputeTargetDelay(last_duration)</code>，其具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> VideoState::ComputeTargetDelay(<span class="keyword">double</span> delay) &#123;</div><div class="line">    <span class="keyword">double</span> sync_threshold, diff = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (GetMasterSyncType() != AV_SYNC_VIDEO_MASTER) &#123; <span class="comment">// 当选择的同步不是同步到视频时，可以理解为当前的同步是视频同步到音频</span></div><div class="line">        diff = vidclk_-&gt;GetClock() - GetMasterClock(); <span class="comment">// 计算视频钟的时间戳与音频钟的时间戳的差值</span></div><div class="line">        sync_threshold = FFMAX(AV_SYNC_THRESHOLD_MIN, FFMIN(AV_SYNC_THRESHOLD_MAX, delay));</div><div class="line">      </div><div class="line">        <span class="comment">/* 下面的逻辑主要是调节延迟时间，当视频播放比音频快，则加大视频下一帧渲染的延迟时间；如果音频播放的比视频快，则缩短延迟时间，加快渲染</span></div><div class="line">        */</div><div class="line">        <span class="keyword">if</span> (!isnan(diff) &amp;&amp; <span class="built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) &#123;</div><div class="line">            <span class="keyword">if</span> (diff &lt;= -sync_threshold) &#123; </div><div class="line">                delay = FFMAX(<span class="number">0</span>, delay + diff);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold &amp;&amp; delay &gt; AV_SYNC_FRAMEDUP_THRESHOLD) &#123;</div><div class="line">                delay = delay + diff;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold) &#123; </div><div class="line">                delay = <span class="number">2</span> * delay;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> delay;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结：</p>
<p>音视频同步技术其实就是尽可能保持音频和视频的PTS的在允许的范围内保持同步。当视频快了，则延长休眠时间，增大下一帧视频渲染的时间间隔；慢了则缩短休眠时间甚至是直接丢帧，以此加快渲染。</p>
<h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3.参考"></a>3.参考</h2><p><a href="http://www.samirchen.com/ffmpeg-tutorial-5/" target="_blank" rel="external">视频同步</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://solasky.info/2017/02/04/JNI总结/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="sola_sky">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://imgsrc.baidu.com/forum/w%3D580/sign=209cc278b019ebc4c0787691b227cf79/9ec6b93eb13533fadb266e33abd3fd1f41345b3d.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Li's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Li's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/04/JNI总结/" itemprop="url">
                  JNI/NDK开发
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-04T10:54:02+08:00">
                2017-02-04
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JNI-NDK开发"><a href="#JNI-NDK开发" class="headerlink" title="JNI/NDK开发"></a>JNI/NDK开发</h1><p>项目中使用了音视频技术，因此不可避免的需要用到jni技术，即java层调用native的代码，下面将介绍一些相关内容，并且有关代码直接采用项目中的例子。</p>
<h2 id="JNI-NDK开发流程"><a href="#JNI-NDK开发流程" class="headerlink" title="JNI/NDK开发流程"></a>JNI/NDK开发流程</h2><h3 id="1-使用CMake构建NDK"><a href="#1-使用CMake构建NDK" class="headerlink" title="1. 使用CMake构建NDK"></a>1. 使用CMake构建NDK</h3><ol>
<li><p>在项目的根目录下(也非一定要根目录，只要后面跟build.gradle中配置的路径相对应就行)创建一个CMakeLists.txt文件，<strong>名字是固定只能是CMakeLists.txt</strong>。</p>
</li>
<li><p>在build.gradle中配置</p>
<ol>
<li><p>在defaultConfig中配置类似的如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">externalNativeBuild &#123;</div><div class="line">  cmake &#123;</div><div class="line">    cppFlags &quot;&quot;</div><div class="line">    abiFilters &apos;x86&apos;, &apos;armeabi&apos;//根据需要的平台进行添加</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在android中配置如下类似代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">externalNativeBuild &#123;</div><div class="line">  cmake &#123;</div><div class="line">    path &quot;CMakeLists.txt&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>其中path对应于CMakeLists.txt的路径(这里用的是相对路径)</strong>。</p>
</li>
<li><p>创建一个用于存放原生源文件的目录如cpp/目录</p>
</li>
</ol>
<p><strong>具体的内容可以参考如下：</strong></p>
<p><a href="https://developer.android.com/studio/projects/add-native-code.html" target="_blank" rel="external">向您的项目添加 C 和 C++ 代码</a></p>
</li>
</ol>
<h3 id="2-编写声明了native方法的Java类"><a href="#2-编写声明了native方法的Java类" class="headerlink" title="2. 编写声明了native方法的Java类"></a>2. 编写声明了native方法的Java类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SolaMediaPlayer</span> <span class="keyword">extends</span> <span class="title">AbstractMediaPlayer</span> </span>&#123;</div><div class="line">  ··· ···</div><div class="line">  <span class="comment">//这部分代码为了演示进行了更改，跟项目里的不一致</span></div><div class="line">  <span class="keyword">static</span> &#123;</div><div class="line">    System.loadLibrary(<span class="string">"solaplayer"</span>); <span class="comment">//加载实现了native函数的动态库</span></div><div class="line">  &#125;</div><div class="line">  ··· ···</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">getCurrentPosition</span><span class="params">()</span></span>; <span class="comment">//声明这是一个native函数，由本地代码实现</span></div><div class="line">  ··· ···</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-实现JVM查找native方法"><a href="#3-实现JVM查找native方法" class="headerlink" title="3. 实现JVM查找native方法"></a>3. 实现JVM查找native方法</h3><p>JVM查找native方法有两种方式：</p>
<ol>
<li>按照JNI命名规范的命名规则</li>
<li>调用JNI提供的<code>RegisterNatives()</code>函数，将本地函数注册到JVM中  </li>
</ol>
<p>主要是用于联系在Java类中声明的native方法，这样在Java层调用native方法时就能找到其相关的实现。</p>
<p>这里只介绍第二种方式。</p>
<p>在存放原生源文件的目录如cpp/目录下创建并编写相关的C/C++文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">··· ···</div><div class="line"><span class="keyword">static</span> JNINativeMethod g_methods[] = &#123;</div><div class="line">        ··· ···</div><div class="line">        &#123;<span class="string">"_pause"</span>, <span class="string">"()V"</span>, (<span class="keyword">void</span> *)Pause&#125;,</div><div class="line">        &#123;<span class="string">"_stop"</span>, <span class="string">"()V"</span>, (<span class="keyword">void</span> *)Stop&#125;,</div><div class="line">        ··· ···</div><div class="line">        &#123;<span class="string">"_flush"</span>, <span class="string">"()V"</span>, (<span class="keyword">void</span> *)Flush&#125;,</div><div class="line">        &#123;<span class="string">"getCurrentPosition"</span>, <span class="string">"()J"</span>, (<span class="keyword">void</span> *)GetCurrentPosition&#125;,</div><div class="line">        ··· ···</div><div class="line">&#125;;</div><div class="line">··· ···</div></pre></td></tr></table></figure>
<p>将Java类中声明的native方法全部列出来，放到<code>JNINativeMethod</code>结构体类型的数组中，<code>JNINativeMethod</code>结构体的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;<span class="comment">//对应Java类中native方法的名称，如之前的getCurrentPosition</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* signature; <span class="comment">//相应方法的签名，如之前的()J,括号里的为name方法的参数类型，由于getCurrentPosition方法没有参数所以不用写，J为其返回类型，因为getCurrentPosition返回long类型，在JNI中long对应的就是J,这个后面会介绍</span></div><div class="line">    <span class="keyword">void</span>* fnPtr; <span class="comment">//本地函数，实现Java层的native方法</span></div><div class="line">&#125; JNINativeMethod;</div></pre></td></tr></table></figure>
<p>也就是说这个结构体将Java层的方法对应到了C/C++层的函数，当在Java层调用name方法时，其实调用的是C/C++层中的fnPtr函数。</p>
<p>接下来就是实现相关的本地函数了，如<code>GetCurrentPosition</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">jlong <span class="title">GetCurrentPosition</span><span class="params">(JNIEnv *env, jobject thiz)</span> </span>&#123;</div><div class="line">  jlong retval = <span class="number">0</span>;</div><div class="line">  ··· ···</div><div class="line">  <span class="keyword">return</span> retval;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后我们需要将本地函数注册到JVM中，由于JNI组件被成功加载和卸载时，会进行函数回调，当VM执行到<code>System.loadLibrary(xxx)</code>方法时，会去执行JNI组件中的<code>JNI_OnLoad()</code>函数，而在VM释放组件时会调用<code>JNI_OnUnload()</code>函数。所以我们可以在<code>JNI_OnLoad()</code>中进行本地函数注册。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function">JNIEXPORT jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="keyword">void</span> *reserved)</span> </span>&#123;</div><div class="line">    JNIEnv *env = <span class="literal">NULL</span>;</div><div class="line">    ··· ···</div><div class="line">    <span class="keyword">if</span> (vm-&gt;GetEnv((<span class="keyword">void</span> **)&amp;env, JNI_VERSION_1_6) != JNI_OK) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    ··· ···</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *class_name = <span class="string">"com/apical/av/SolaMediaPlayer"</span>; <span class="comment">//Java类的全限定名称,将.改成/</span></div><div class="line">    g_clazz.clazz = env-&gt;FindClass(class_name); <span class="comment">//找到相应Java类对应的jclass对象</span></div><div class="line">    <span class="comment">// 通过RegisterNatives将本地函数注册到JVM中，然后Java层就可以调用C/C++层对应的函数</span></div><div class="line">    <span class="keyword">if</span> (env-&gt;RegisterNatives(g_clazz.clazz, g_methods , <span class="keyword">sizeof</span>(g_methods) / <span class="keyword">sizeof</span>(g_methods[<span class="number">0</span>])) &lt; <span class="number">0</span>) &#123;</div><div class="line">        env-&gt;DeleteLocalRef(g_clazz.clazz);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    ··· ···</div><div class="line">    <span class="keyword">return</span> JNI_VERSION_1_6;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>经过这一步之后，Java层中的native方法就能正确找到native层的函数实现了。</p>
<p><strong>可以参考如下链接：</strong></p>
<p><a href="http://blog.csdn.net/xyang81/article/details/41854185" target="_blank" rel="external">JVM查找java native方法的规则</a></p>
<h3 id="4-编写具体的CMakeLists-txt内容"><a href="#4-编写具体的CMakeLists-txt内容" class="headerlink" title="4.编写具体的CMakeLists.txt内容"></a>4.编写具体的CMakeLists.txt内容</h3><p>CMakeLists.txt的作用是用于配置如何产生想要的库，这里简单贴一下播放器部分的CMakeLists.txt内容</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 这里是固定的要写版本</span></div><div class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>) </div><div class="line">··· ··· </div><div class="line"><span class="comment"># 添加当前目录下的所有源文件</span></div><div class="line"><span class="keyword">aux_source_directory</span>(. SOLA_PLAYER_LISTS)</div><div class="line">··· ···</div><div class="line"><span class="comment"># 以动态库形式增加一个solaplayer库，将相关的源文件加入这个动态库</span></div><div class="line"><span class="keyword">add_library</span>(solaplayer SHARED <span class="variable">$&#123;SOLA_PLAYER_LISTS&#125;</span> j4a/j4a_base.cpp j4a/audio_track.cpp)</div><div class="line"><span class="comment"># 链接一些在solaplayer库中需要使用的其它库，就是在之前添加的那些源文件中需要用到的其它的库的函数、类等</span></div><div class="line"><span class="keyword">target_link_libraries</span>(solaplayer sdl ffmpeg <span class="variable">$&#123;jnigraphics-lib&#125;</span> yuv <span class="variable">$&#123;android-lib&#125;</span>)</div></pre></td></tr></table></figure>
<p>然后所有情况都正常的情况下只要在android studio一运行就会产生libsolaplayer.so库，这样在执行<code>System.loadLibrary(&quot;solaplayer&quot;)</code>时就可以加载这个库，而不会发生找不到的情况了。</p>
<p>具体的有关cmake的内容可以参考如下：</p>
<p><a href="http://sewm.pku.edu.cn/src/paradise/reference/CMake%20Practice.pdf" target="_blank" rel="external">CMake实践</a></p>
<p><a href="https://cmake.org/cmake-tutorial/" target="_blank" rel="external">CMake官方文档</a></p>
<h2 id="本地数据类型及与Java数据类型的映射关系"><a href="#本地数据类型及与Java数据类型的映射关系" class="headerlink" title="本地数据类型及与Java数据类型的映射关系"></a>本地数据类型及与Java数据类型的映射关系</h2><h3 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1.基本类型"></a>1.基本类型</h3><table>
<thead>
<tr>
<th style="text-align:left">Java基本类型</th>
<th>本地类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>char</strong></td>
<td><strong>jcahr</strong></td>
<td><strong>unsigned 16 bits</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>short</strong></td>
<td><strong>jshort</strong></td>
<td><strong>signed 16 bits</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>int</strong></td>
<td><strong>jint</strong></td>
<td><strong>signed 32 bits</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>long</strong></td>
<td><strong>jlong</strong></td>
<td><strong>signed 64 bits</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>boolean</strong></td>
<td><strong>jboolean</strong></td>
<td><strong>unsigned 8 bits</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>byte</strong></td>
<td><strong>jbyte</strong></td>
<td><strong>signed 8 bits</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>float</strong></td>
<td><strong>jfloat</strong></td>
<td><strong>32 bits</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>double</strong></td>
<td><strong>jdouble</strong></td>
<td><strong>64 bits</strong></td>
</tr>
</tbody>
</table>
<h3 id="2-引用数据类型"><a href="#2-引用数据类型" class="headerlink" title="2.引用数据类型"></a>2.引用数据类型</h3><table>
<thead>
<tr>
<th>Java类型</th>
<th>本地类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Object</strong></td>
<td><strong>jobject</strong></td>
</tr>
<tr>
<td><strong>Class</strong></td>
<td><strong>jclass</strong></td>
</tr>
<tr>
<td><strong>String</strong></td>
<td><strong>jstring</strong></td>
</tr>
<tr>
<td><strong>Object[]</strong></td>
<td><strong>jobjectArray</strong></td>
</tr>
<tr>
<td><strong>boolean[]</strong></td>
<td><strong>jbooleanArray</strong>f</td>
</tr>
<tr>
<td><strong>byte[]</strong></td>
<td><strong>jbyteArray</strong></td>
</tr>
<tr>
<td><strong>char[]</strong></td>
<td><strong>jcharArray</strong></td>
</tr>
<tr>
<td><strong>short[]</strong></td>
<td><strong>jshortArray</strong></td>
</tr>
<tr>
<td><strong>int[]</strong></td>
<td><strong>jintArray</strong></td>
</tr>
<tr>
<td><strong>long[]</strong></td>
<td><strong>jlongArray</strong></td>
</tr>
<tr>
<td><strong>float[]</strong></td>
<td><strong>jfloatArray</strong></td>
</tr>
<tr>
<td><strong>double[]</strong></td>
<td><strong>jdoubleArray</strong></td>
</tr>
</tbody>
</table>
<p><strong>特别注意：</strong></p>
<ol>
<li>多维数组（包括二维数组）都是引用类型，需要使用objectArray类型来进行表示，如二维数组就是指向一位数组的数组。</li>
</ol>
<h3 id="3-域描述符"><a href="#3-域描述符" class="headerlink" title="3. 域描述符"></a>3. 域描述符</h3><p>1.基本类型描述符</p>
<table>
<thead>
<tr>
<th>Java类型</th>
<th>描述符</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>boolean</strong></td>
<td><strong>Z</strong></td>
</tr>
<tr>
<td><strong>byte</strong></td>
<td><strong>B</strong></td>
</tr>
<tr>
<td><strong>char</strong></td>
<td><strong>C</strong></td>
</tr>
<tr>
<td><strong>short</strong></td>
<td><strong>S</strong></td>
</tr>
<tr>
<td><strong>int</strong></td>
<td><strong>I</strong></td>
</tr>
<tr>
<td><strong>long</strong></td>
<td><strong>J</strong></td>
</tr>
<tr>
<td><strong>float</strong></td>
<td><strong>F</strong></td>
</tr>
<tr>
<td><strong>double</strong></td>
<td><strong>D</strong></td>
</tr>
</tbody>
</table>
<p>上文 <code>{&quot;getCurrentPosition&quot;, &quot;()J&quot;, (void *)GetCurrentPosition}</code>中的<em>J</em>就是指long类型的描述符了。</p>
<p>2.引用类型描述符</p>
<p>一般引用类型为(<em>L + 该类型类描述符 + ;</em>) （主要其中的的分号 <strong>“;”</strong>，这是描述符的一部分，而不是分段的意思），而<strong>类描述符</strong>是类全限定名称将原来的.分隔符换成/分隔符。如Java中的java.lang.String的类描述符就是java/lang/String。所以其域描述符就为<code>Ljava/lang/String;</code>。</p>
<h2 id="JNI异常处理"><a href="#JNI异常处理" class="headerlink" title="JNI异常处理"></a>JNI异常处理</h2><p>这里就简介介绍一下项目里的一个函数（来自于B站ijkplayer的源码）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">J4A_ExceptionCheck__catchAll</span><span class="params">(JNIEnv *env)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</div><div class="line">        env-&gt;ExceptionDescribe();</div><div class="line">        env-&gt;ExceptionClear();</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用<code>ExceptionCheck()</code>函数检查一下最近JNI调用是否发送了异常，如果有则返回JNI_TRUE，则会执行上面代码中<code>if</code>花括号中的语句；若没有异常则返回JNI_FALSE。当检查到有异常时，调用<code>ExceptionDescribe()</code>来打印相关异常的堆栈信息，然后再调用<code>ExceptionClear()</code>函数来清除异常堆栈信息的缓冲区（防止后续异常堆栈信息覆盖之前的异常信息）。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://blog.csdn.net/column/details/blogjnindk.html" target="_blank" rel="external">JNI/NDK开发指南</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://solasky.info/2016/06/30/FFmpeg的一些函数和结构/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="sola_sky">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://imgsrc.baidu.com/forum/w%3D580/sign=209cc278b019ebc4c0787691b227cf79/9ec6b93eb13533fadb266e33abd3fd1f41345b3d.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Li's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Li's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/30/FFmpeg的一些函数和结构/" itemprop="url">
                  FFmpeg的一些函数和结构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-30T19:34:36+08:00">
                2016-06-30
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>av_new_stream()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Can only be called in the read_header() function. If the flag</div><div class="line"> * AVFMTCTX_NOHEADER is in the format context, then new streams</div><div class="line"> * can be added in read_packet too.</div><div class="line"> */</div><div class="line"><span class="function">AVStream *<span class="title">av_new_stream</span><span class="params">(AVFormatContext *s, <span class="keyword">int</span> id)</span></span></div></pre></td></tr></table></figure>
<p>为媒体文件添加一个流，一般作为输出的媒体文件容器添加音视频流。</p>
<p><strong>dump_format()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">attribute_deprecated <span class="keyword">void</span> <span class="title">dump_format</span><span class="params">(AVFormatContext *ic,</span></span></div><div class="line">                                      <span class="keyword">int</span> index,</div><div class="line">                                      constchar *url,</div><div class="line">                                      <span class="keyword">int</span> is_output);</div></pre></td></tr></table></figure>
<p>该函数的作用就是检查下初始化过程中设置的参数是否符合规范。</p>
<p><strong>av_set_parameters()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">attribute_deprecated <span class="keyword">int</span> <span class="title">av_set_parameters</span><span class="params">(AVFormatContext *s, AVFormatParameters *ap)</span></span></div></pre></td></tr></table></figure>
<p>设置初始化参数</p>
<p><strong>av_write_header()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">attribute_deprecated <span class="keyword">int</span> <span class="title">av_write_header</span><span class="params">(AVFormatContext *s)</span></span></div></pre></td></tr></table></figure>
<p>把流头信息写入到媒体文件中。如果成功返回0。</p>
<p><strong>AVCodecContext</strong></p>
<ul>
<li>enum AVMediaType codec_type：编解码器的类型（视频，音频…）</li>
<li>struct AVCodec  *codec：采用的解码器AVCodec（H.264,MPEG2…）</li>
<li>int bit_rate：平均比特率</li>
<li>uint8_t *extradata; int extradata_size：针对特定编码器包含的附加信息（例如对于H.264解码器来说，存储SPS，PPS等）</li>
<li>AVRational time_base：根据该参数，可以把PTS转化为实际的时间（单位为秒s）</li>
<li>int width, height：如果是视频的话，代表宽和高</li>
<li>int refs：运动估计参考帧的个数（H.264的话会有多帧，MPEG2这类的一般就没有了）</li>
<li>int sample_rate：采样率（音频）</li>
<li>int channels：声道数（音频）</li>
<li>enum AVSampleFormat sample_fmt：采样格式</li>
<li>int profile：型（H.264里面就有，其他编码标准应该也有）</li>
<li>int level：级（和profile差不太多）</li>
</ul>
<p>在这里需要注意：AVCodecContext中很多的参数是编码的时候使用的，而不是解码的时候使用的。</p>
<p><strong>codec_type</strong></p>
<p>编解码器类型有一下几种：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> AVMediaType &#123;  </div><div class="line">    AVMEDIA_TYPE_UNKNOWN = <span class="number">-1</span>,  <span class="comment">///&lt; Usually treated as AVMEDIA_TYPE_DATA  </span></div><div class="line">    AVMEDIA_TYPE_VIDEO,  </div><div class="line">    AVMEDIA_TYPE_AUDIO,  </div><div class="line">    AVMEDIA_TYPE_DATA,          <span class="comment">///&lt; Opaque data information usually continuous  </span></div><div class="line">    AVMEDIA_TYPE_SUBTITLE,  </div><div class="line">    AVMEDIA_TYPE_ATTACHMENT,    <span class="comment">///&lt; Opaque data information usually sparse  </span></div><div class="line">    AVMEDIA_TYPE_NB  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>sample_fmt</strong></p>
<p>在FFMPEG中音频采样格式有以下几种：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> AVSampleFormat &#123;  </div><div class="line">    AV_SAMPLE_FMT_NONE = <span class="number">-1</span>,  </div><div class="line">    AV_SAMPLE_FMT_U8,          <span class="comment">///&lt; unsigned 8 bits  </span></div><div class="line">    AV_SAMPLE_FMT_S16,         <span class="comment">///&lt; signed 16 bits  </span></div><div class="line">    AV_SAMPLE_FMT_S32,         <span class="comment">///&lt; signed 32 bits  </span></div><div class="line">    AV_SAMPLE_FMT_FLT,         <span class="comment">///&lt; float  </span></div><div class="line">    AV_SAMPLE_FMT_DBL,         <span class="comment">///&lt; double  </span></div><div class="line">  </div><div class="line">    AV_SAMPLE_FMT_U8P,         <span class="comment">///&lt; unsigned 8 bits, planar  </span></div><div class="line">    AV_SAMPLE_FMT_S16P,        <span class="comment">///&lt; signed 16 bits, planar  </span></div><div class="line">    AV_SAMPLE_FMT_S32P,        <span class="comment">///&lt; signed 32 bits, planar  </span></div><div class="line">    AV_SAMPLE_FMT_FLTP,        <span class="comment">///&lt; float, planar  </span></div><div class="line">    AV_SAMPLE_FMT_DBLP,        <span class="comment">///&lt; double, planar  </span></div><div class="line">  </div><div class="line">    AV_SAMPLE_FMT_NB           <span class="comment">///&lt; Number of sample formats. DO NOT USE if linking dynamically  </span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>AVPacket</strong></p>
<p>AVPacket是存储压缩编码数据相关信息的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> AVPacket &#123;  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * Presentation timestamp in AVStream-&gt;time_base units; the time at which </div><div class="line">     * the decompressed packet will be presented to the user. </div><div class="line">     * Can be AV_NOPTS_VALUE if it is not stored in the file. </div><div class="line">     * pts MUST be larger or equal to dts as presentation cannot happen before </div><div class="line">     * decompression, unless one wants to view hex dumps. Some formats misuse </div><div class="line">     * the terms dts and pts/cts to mean something different. Such timestamps </div><div class="line">     * must be converted to true pts/dts before they are stored in AVPacket. </div><div class="line">     */  </div><div class="line">    <span class="keyword">int64_t</span> pts;  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * Decompression timestamp in AVStream-&gt;time_base units; the time at which </div><div class="line">     * the packet is decompressed. </div><div class="line">     * Can be AV_NOPTS_VALUE if it is not stored in the file. </div><div class="line">     */  </div><div class="line">    <span class="keyword">int64_t</span> dts;  </div><div class="line">    <span class="keyword">uint8_t</span> *data;  </div><div class="line">    <span class="keyword">int</span>   size;  </div><div class="line">    <span class="keyword">int</span>   stream_index;  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * A combination of AV_PKT_FLAG values </div><div class="line">     */  </div><div class="line">    <span class="keyword">int</span>   flags;  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * Additional packet data that can be provided by the container. </div><div class="line">     * Packet can contain several types of side information. </div><div class="line">     */  </div><div class="line">    <span class="keyword">struct</span> &#123;  </div><div class="line">        <span class="keyword">uint8_t</span> *data;  </div><div class="line">        <span class="keyword">int</span>      size;  </div><div class="line">        <span class="keyword">enum</span> AVPacketSideDataType type;  </div><div class="line">    &#125; *side_data;  </div><div class="line">    <span class="keyword">int</span> side_data_elems;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * Duration of this packet in AVStream-&gt;time_base units, 0 if unknown. </div><div class="line">     * Equals next_pts - this_pts in presentation order. </div><div class="line">     */  </div><div class="line">    <span class="keyword">int</span>   duration;  </div><div class="line">    <span class="keyword">void</span>  (*destruct)(<span class="keyword">struct</span> AVPacket *);  </div><div class="line">    <span class="keyword">void</span>  *priv;  </div><div class="line">    <span class="keyword">int64_t</span> pos;                            <span class="comment">///&lt; byte position in stream, -1 if unknown  </span></div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * Time difference in AVStream-&gt;time_base units from the pts of this </div><div class="line">     * packet to the point at which the output from the decoder has converged </div><div class="line">     * independent from the availability of previous frames. That is, the </div><div class="line">     * frames are virtually identical no matter if decoding started from </div><div class="line">     * the very first frame or from this keyframe. </div><div class="line">     * Is AV_NOPTS_VALUE if unknown. </div><div class="line">     * This field is not the display duration of the current packet. </div><div class="line">     * This field has no meaning if the packet does not have AV_PKT_FLAG_KEY </div><div class="line">     * set. </div><div class="line">     * </div><div class="line">     * The purpose of this field is to allow seeking in streams that have no </div><div class="line">     * keyframes in the conventional sense. It corresponds to the </div><div class="line">     * recovery point SEI in H.264 and match_time_delta in NUT. It is also </div><div class="line">     * essential for some types of subtitle streams to ensure that all </div><div class="line">     * subtitles are correctly displayed after seeking. </div><div class="line">     */  </div><div class="line">    <span class="keyword">int64_t</span> convergence_duration;  </div><div class="line">&#125; AVPacket;</div></pre></td></tr></table></figure>
<p>uint8_t *data：压缩编码的数据。<br>例如对于H.264来说。1个AVPacket的data通常对应一个NAL。<br>注意：在这里只是对应，而不是一模一样。他们之间有微小的差别：使用FFMPEG类库分离出多媒体文件中的H.264码流<br>因此在使用FFMPEG进行视音频处理的时候，常常可以将得到的AVPacket的data数据直接写成文件，从而得到视音频的码流文件。<br>int   size：data的大小<br>int64_t pts：显示时间戳<br>int64_t dts：解码时间戳<br>int   stream_index：标识该AVPacket所属的视频/音频流。</p>
<p><strong>av_init_packet()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">av_init_packet</span><span class="params">(AVPacket *pkt)</span></span>;</div></pre></td></tr></table></figure>
<p>// 使用默认值初始化AVPacket<br>// 定义AVPacket对象后,请使用av_init_packet进行初始化</p>
<p><strong>av_free_packet()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">av_free_packet</span><span class="params">(AVPacket *pkt)</span></span>;</div></pre></td></tr></table></figure>
<p>用于释放AVPacket对象</p>
<p><strong>av_read_frame()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_read_frame</span><span class="params">(AVFormatContext *s, AVPacket *pkt)</span></span>;</div></pre></td></tr></table></figure>
<p>从输入源文件容器中读取一个AVPacket数据包。该函数读出的包并不每次都是有效的,对于读出的包我们都应该进行相应的解码(视频解码/音频解码),在返回值&gt;=0时,循环调用该函数进行读取,循环调用之前请调用av_free_packet函数清理AVPacket。</p>
<p><strong>avcodec_decode_video2()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_decode_video2</span><span class="params">(AVCodecContext *avctx, AVFrame *picture,</span></span></div><div class="line">                         <span class="keyword">int</span> *got_picture_ptr,</div><div class="line">                         AVPacket *avpkt);</div></pre></td></tr></table></figure>
<ul>
<li>解码视频流AVPacket</li>
<li>使用av_read_frame读取媒体流后需要进行判断,如果为视频流则调用该函数解码</li>
<li>返回结果&lt;0时失败,此时程序应该退出检查原因</li>
<li>返回&gt;=0时正常,假设 读取包为:AVPacket vPacket 返回值为 int vLen; 每次解码正常时,对vPacket做如下处理:<br>vPacket.size -= vLen;<br>vPacket.data += vLen;</li>
<li>如果 vPacket.size==0,则继续读下一流包,否则继续调度该方法进行解码,直到vPacket.size==0</li>
<li>返回 got_picture_ptr &gt; 0 时,表示解码到了AVFrame *picture,其后可以对picture进程处理</li>
</ul>
<p><strong>avcodec_decode_audio3()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_decode_audio3</span><span class="params">(AVCodecContext *avctx, <span class="keyword">int16_t</span> *samples,</span></span></div><div class="line">                         <span class="keyword">int</span> *frame_size_ptr,</div><div class="line">                         AVPacket *avpkt);</div></pre></td></tr></table></figure>
<p><strong>AVCodec</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> AVCodec &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Name of the codec implementation.</div><div class="line">     * The name is globally unique among encoders and among decoders (but an</div><div class="line">     * encoder and a decoder can share the same name).</div><div class="line">     * This is the primary way to find a codec from the user perspective.</div><div class="line">     */</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Descriptive name for the codec, meant to be more human readable than name.</div><div class="line">     * You should use the NULL_IF_CONFIG_SMALL() macro to define it.</div><div class="line">     */</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *long_name;</div><div class="line">    <span class="keyword">enum</span> AVMediaType type;</div><div class="line">    <span class="keyword">enum</span> AVCodecID id;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Codec capabilities.</div><div class="line">     * see AV_CODEC_CAP_*</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> capabilities;</div><div class="line">    <span class="keyword">const</span> AVRational *supported_framerates; <span class="comment">///&lt; array of supported framerates, or NULL if any, array is terminated by &#123;0,0&#125;</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">enum</span> AVPixelFormat *pix_fmts;     <span class="comment">///&lt; array of supported pixel formats, or NULL if unknown, array is terminated by -1</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *supported_samplerates;       <span class="comment">///&lt; array of supported audio samplerates, or NULL if unknown, array is terminated by 0</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">enum</span> AVSampleFormat *sample_fmts; <span class="comment">///&lt; array of supported sample formats, or NULL if unknown, array is terminated by -1</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> *channel_layouts;         <span class="comment">///&lt; array of support channel layouts, or NULL if unknown. array is terminated by 0</span></div><div class="line">    <span class="keyword">uint8_t</span> max_lowres;                     <span class="comment">///&lt; maximum value for lowres supported by the decoder, no direct access, use av_codec_get_max_lowres()</span></div><div class="line">    <span class="keyword">const</span> AVClass *priv_class;              <span class="comment">///&lt; AVClass for the private context</span></div><div class="line">    <span class="keyword">const</span> AVProfile *profiles;              <span class="comment">///&lt; array of recognized profiles, or NULL if unknown, array is terminated by &#123;FF_PROFILE_UNKNOWN&#125;</span></div><div class="line"></div><div class="line">    <span class="comment">/*****************************************************************</span></div><div class="line">     * No fields below this line are part of the public API. They</div><div class="line">     * may not be used outside of libavcodec and can be changed and</div><div class="line">     * removed at will.</div><div class="line">     * New public fields should be added right above.</div><div class="line">     *****************************************************************</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> priv_data_size;</div><div class="line">    <span class="keyword">struct</span> AVCodec *next;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * @name Frame-level threading support functions</div><div class="line">     * @&#123;</div><div class="line">     */</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * If defined, called on thread contexts when they are created.</div><div class="line">     * If the codec allocates writable tables in init(), re-allocate them here.</div><div class="line">     * priv_data will be set to a copy of the original.</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> (*init_thread_copy)(AVCodecContext *);</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Copy necessary context variables from a previous thread context to the current one.</div><div class="line">     * If not defined, the next thread will start automatically; otherwise, the codec</div><div class="line">     * must call ff_thread_finish_setup().</div><div class="line">     *</div><div class="line">     * dst and src will (rarely) point to the same context, in which case memcpy should be skipped.</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> (*update_thread_context)(AVCodecContext *dst, <span class="keyword">const</span> AVCodecContext *src);</div><div class="line">    <span class="comment">/** @&#125; */</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Private codec-specific defaults.</div><div class="line">     */</div><div class="line">    <span class="keyword">const</span> AVCodecDefault *defaults;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Initialize codec static data, called from avcodec_register().</div><div class="line">     */</div><div class="line">    <span class="keyword">void</span> (*init_static_data)(<span class="keyword">struct</span> AVCodec *codec);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> (*init)(AVCodecContext *);</div><div class="line">    <span class="keyword">int</span> (*encode_sub)(AVCodecContext *, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> buf_size,</div><div class="line">                      <span class="keyword">const</span> <span class="keyword">struct</span> AVSubtitle *sub);</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Encode data to an AVPacket.</div><div class="line">     *</div><div class="line">     * @param      avctx          codec context</div><div class="line">     * @param      avpkt          output AVPacket (may contain a user-provided buffer)</div><div class="line">     * @param[in]  frame          AVFrame containing the raw data to be encoded</div><div class="line">     * @param[out] got_packet_ptr encoder sets to 0 or 1 to indicate that a</div><div class="line">     *                            non-empty packet was returned in avpkt.</div><div class="line">     * @return 0 on success, negative error code on failure</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> (*encode2)(AVCodecContext *avctx, AVPacket *avpkt, <span class="keyword">const</span> AVFrame *frame,</div><div class="line">                   <span class="keyword">int</span> *got_packet_ptr);</div><div class="line">    <span class="keyword">int</span> (*decode)(AVCodecContext *, <span class="keyword">void</span> *outdata, <span class="keyword">int</span> *outdata_size, AVPacket *avpkt);</div><div class="line">    <span class="keyword">int</span> (*close)(AVCodecContext *);</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Decode/encode API with decoupled packet/frame dataflow. The API is the</div><div class="line">     * same as the avcodec_ prefixed APIs (avcodec_send_frame() etc.), except</div><div class="line">     * that:</div><div class="line">     * - never called if the codec is closed or the wrong type,</div><div class="line">     * - AVPacket parameter change side data is applied right before calling</div><div class="line">     *   AVCodec-&gt;send_packet,</div><div class="line">     * - if AV_CODEC_CAP_DELAY is not set, drain packets or frames are never sent,</div><div class="line">     * - only one drain packet is ever passed down (until the next flush()),</div><div class="line">     * - a drain AVPacket is always NULL (no need to check for avpkt-&gt;size).</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> (*send_frame)(AVCodecContext *avctx, <span class="keyword">const</span> AVFrame *frame);</div><div class="line">    <span class="keyword">int</span> (*send_packet)(AVCodecContext *avctx, <span class="keyword">const</span> AVPacket *avpkt);</div><div class="line">    <span class="keyword">int</span> (*receive_frame)(AVCodecContext *avctx, AVFrame *frame);</div><div class="line">    <span class="keyword">int</span> (*receive_packet)(AVCodecContext *avctx, AVPacket *avpkt);</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Flush buffers.</div><div class="line">     * Will be called when seeking</div><div class="line">     */</div><div class="line">    <span class="keyword">void</span> (*flush)(AVCodecContext *);</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Internal codec capabilities.</div><div class="line">     * See FF_CODEC_CAP_* in internal.h</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> caps_internal;</div><div class="line">&#125; AVCodec;</div></pre></td></tr></table></figure>
<p>最主要的几个变量：</p>
<ul>
<li>const char *name：编解码器的名字，比较短</li>
<li>const char *long_name：编解码器的名字，全称，比较长</li>
<li>enum AVMediaType type：指明了类型，是视频，音频，还是字幕</li>
<li>enum AVCodecID id：ID，不重复</li>
<li>const AVRational *supported_framerates：支持的帧率（仅视频）</li>
<li>const enum AVPixelFormat *pix_fmts：支持的像素格式（仅视频）</li>
<li>const int *supported_samplerates：支持的采样率（仅音频）</li>
<li>const enum AVSampleFormat *sample_fmts：支持的采样格式（仅音频）</li>
<li>const uint64_t *channel_layouts：支持的声道数（仅音频）</li>
<li>int priv_data_size：私有数据的大小</li>
</ul>
<p><strong>enum AVMediaType</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> AVMediaType &#123;  </div><div class="line">    AVMEDIA_TYPE_UNKNOWN = <span class="number">-1</span>,  <span class="comment">///&lt; Usually treated as AVMEDIA_TYPE_DATA  </span></div><div class="line">    AVMEDIA_TYPE_VIDEO,  </div><div class="line">    AVMEDIA_TYPE_AUDIO,  </div><div class="line">    AVMEDIA_TYPE_DATA,          <span class="comment">///&lt; Opaque data information usually continuous  </span></div><div class="line">    AVMEDIA_TYPE_SUBTITLE,  </div><div class="line">    AVMEDIA_TYPE_ATTACHMENT,    <span class="comment">///&lt; Opaque data information usually sparse  </span></div><div class="line">    AVMEDIA_TYPE_NB  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>enum AVCodecId</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> AVCodecID &#123;  </div><div class="line">    AV_CODEC_ID_NONE,  </div><div class="line">  </div><div class="line">    <span class="comment">/* video codecs */</span>  </div><div class="line">    AV_CODEC_ID_MPEG1VIDEO,  </div><div class="line">    AV_CODEC_ID_MPEG2VIDEO, <span class="comment">///&lt; preferred ID for MPEG-1/2 video decoding  </span></div><div class="line">    AV_CODEC_ID_MPEG2VIDEO_XVMC,  </div><div class="line">    AV_CODEC_ID_H261,  </div><div class="line">    AV_CODEC_ID_H263,  </div><div class="line">    AV_CODEC_ID_RV10,  </div><div class="line">    AV_CODEC_ID_RV20,  </div><div class="line">    AV_CODEC_ID_MJPEG,  </div><div class="line">    AV_CODEC_ID_MJPEGB,  </div><div class="line">    AV_CODEC_ID_LJPEG,  </div><div class="line">    AV_CODEC_ID_SP5X,  </div><div class="line">    AV_CODEC_ID_JPEGLS,  </div><div class="line">    AV_CODEC_ID_MPEG4,  </div><div class="line">    AV_CODEC_ID_RAWVIDEO,  </div><div class="line">    AV_CODEC_ID_MSMPEG4V1,  </div><div class="line">    AV_CODEC_ID_MSMPEG4V2,  </div><div class="line">    AV_CODEC_ID_MSMPEG4V3,  </div><div class="line">    AV_CODEC_ID_WMV1,  </div><div class="line">    AV_CODEC_ID_WMV2,  </div><div class="line">    AV_CODEC_ID_H263P,  </div><div class="line">    AV_CODEC_ID_H263I,  </div><div class="line">    AV_CODEC_ID_FLV1,  </div><div class="line">    AV_CODEC_ID_SVQ1,  </div><div class="line">    AV_CODEC_ID_SVQ3,  </div><div class="line">    AV_CODEC_ID_DVVIDEO,  </div><div class="line">    AV_CODEC_ID_HUFFYUV,  </div><div class="line">    AV_CODEC_ID_CYUV,  </div><div class="line">    AV_CODEC_ID_H264,  </div><div class="line">    ...（代码太长，略）  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>const enum AVPixelFormat *pix_fmts</strong></p>
<p>AVPixelFormat定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">enum AVPixelFormat &#123;  </div><div class="line">    AV_PIX_FMT_NONE = -1,  </div><div class="line">    AV_PIX_FMT_YUV420P,   ///&lt; planar YUV 4:2:0, 12bpp, (1 Cr &amp; Cb sample per 2x2 Y samples)  </div><div class="line">    AV_PIX_FMT_YUYV422,   ///&lt; packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr  </div><div class="line">    AV_PIX_FMT_RGB24,     ///&lt; packed RGB 8:8:8, 24bpp, RGBRGB...  </div><div class="line">    AV_PIX_FMT_BGR24,     ///&lt; packed RGB 8:8:8, 24bpp, BGRBGR...  </div><div class="line">    AV_PIX_FMT_YUV422P,   ///&lt; planar YUV 4:2:2, 16bpp, (1 Cr &amp; Cb sample per 2x1 Y samples)  </div><div class="line">    AV_PIX_FMT_YUV444P,   ///&lt; planar YUV 4:4:4, 24bpp, (1 Cr &amp; Cb sample per 1x1 Y samples)  </div><div class="line">    AV_PIX_FMT_YUV410P,   ///&lt; planar YUV 4:1:0,  9bpp, (1 Cr &amp; Cb sample per 4x4 Y samples)  </div><div class="line">    AV_PIX_FMT_YUV411P,   ///&lt; planar YUV 4:1:1, 12bpp, (1 Cr &amp; Cb sample per 4x1 Y samples)  </div><div class="line">    AV_PIX_FMT_GRAY8,     ///&lt;        Y        ,  8bpp  </div><div class="line">    AV_PIX_FMT_MONOWHITE, ///&lt;        Y        ,  1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb  </div><div class="line">    AV_PIX_FMT_MONOBLACK, ///&lt;        Y        ,  1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb  </div><div class="line">    AV_PIX_FMT_PAL8,      ///&lt; 8 bit with PIX_FMT_RGB32 palette  </div><div class="line">    AV_PIX_FMT_YUVJ420P,  ///&lt; planar YUV 4:2:0, 12bpp, full scale (JPEG), deprecated in favor of PIX_FMT_YUV420P and setting color_range  </div><div class="line">    AV_PIX_FMT_YUVJ422P,  ///&lt; planar YUV 4:2:2, 16bpp, full scale (JPEG), deprecated in favor of PIX_FMT_YUV422P and setting color_range  </div><div class="line">    AV_PIX_FMT_YUVJ444P,  ///&lt; planar YUV 4:4:4, 24bpp, full scale (JPEG), deprecated in favor of PIX_FMT_YUV444P and setting color_range  </div><div class="line">    AV_PIX_FMT_XVMC_MPEG2_MC,///&lt; XVideo Motion Acceleration via common packet passing  </div><div class="line">    AV_PIX_FMT_XVMC_MPEG2_IDCT,  </div><div class="line">    ...（代码太长，略）  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>const enum AVSampleFormat *sample_fmts</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> AVSampleFormat &#123;  </div><div class="line">    AV_SAMPLE_FMT_NONE = <span class="number">-1</span>,  </div><div class="line">    AV_SAMPLE_FMT_U8,          <span class="comment">///&lt; unsigned 8 bits  </span></div><div class="line">    AV_SAMPLE_FMT_S16,         <span class="comment">///&lt; signed 16 bits  </span></div><div class="line">    AV_SAMPLE_FMT_S32,         <span class="comment">///&lt; signed 32 bits  </span></div><div class="line">    AV_SAMPLE_FMT_FLT,         <span class="comment">///&lt; float  </span></div><div class="line">    AV_SAMPLE_FMT_DBL,         <span class="comment">///&lt; double  </span></div><div class="line">  </div><div class="line">    AV_SAMPLE_FMT_U8P,         <span class="comment">///&lt; unsigned 8 bits, planar  </span></div><div class="line">    AV_SAMPLE_FMT_S16P,        <span class="comment">///&lt; signed 16 bits, planar  </span></div><div class="line">    AV_SAMPLE_FMT_S32P,        <span class="comment">///&lt; signed 32 bits, planar  </span></div><div class="line">    AV_SAMPLE_FMT_FLTP,        <span class="comment">///&lt; float, planar  </span></div><div class="line">    AV_SAMPLE_FMT_DBLP,        <span class="comment">///&lt; double, planar  </span></div><div class="line">  </div><div class="line">    AV_SAMPLE_FMT_NB           <span class="comment">///&lt; Number of sample formats. DO NOT USE if linking dynamically  </span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>每个编解码器对应一个该结构体，查看一下ffmpeg的源码，我们可以在/libavcodec/h264.c文件中看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">AVCodec ff_h264_decoder = &#123;</div><div class="line">    .name                  = &quot;h264&quot;,</div><div class="line">    .long_name             = NULL_IF_CONFIG_SMALL(&quot;H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10&quot;),</div><div class="line">    .type                  = AVMEDIA_TYPE_VIDEO,</div><div class="line">    .id                    = AV_CODEC_ID_H264,</div><div class="line">    .priv_data_size        = sizeof(H264Context),</div><div class="line">    .init                  = ff_h264_decode_init,</div><div class="line">    .close                 = h264_decode_end,</div><div class="line">    .decode                = h264_decode_frame,</div><div class="line">    .capabilities          = /*AV_CODEC_CAP_DRAW_HORIZ_BAND |*/ AV_CODEC_CAP_DR1 |</div><div class="line">                             AV_CODEC_CAP_DELAY | AV_CODEC_CAP_SLICE_THREADS |</div><div class="line">                             AV_CODEC_CAP_FRAME_THREADS,</div><div class="line">    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE,</div><div class="line">    .flush                 = flush_dpb,</div><div class="line">    .init_thread_copy      = ONLY_IF_THREADS_ENABLED(decode_init_thread_copy),</div><div class="line">    .update_thread_context = ONLY_IF_THREADS_ENABLED(ff_h264_update_thread_context),</div><div class="line">    .profiles              = NULL_IF_CONFIG_SMALL(ff_h264_profiles),</div><div class="line">    .priv_class            = &amp;h264_class,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>下面简单介绍一下遍历ffmpeg中的解码器信息的方法（这些解码器以一个链表的形式存储）：<br>1.注册所有编解码器：av_register_all();<br>2.声明一个AVCodec类型的指针，比如说AVCodec* first_c;<br>3.调用av_codec_next()函数，即可获得指向链表下一个解码器的指针，循环往复可以获得所有解码器的信息。注意，如果想要获得指向第一个解码器的指针，则需要将该函数的参数设置为NULL。</p>
<p><strong>AVStream</strong></p>
<p>AVStream是存储每一个视频/音频流信息的结构体，重要的变量如下：</p>
<ul>
<li>int index：标识该视频/音频流</li>
<li>AVCodecContext *codec：指向该视频/音频流的AVCodecContext（它们是一一对应的关系）</li>
<li>AVRational time_base：时基。通过该值可以把PTS，DTS转化为真正的时间。FFMPEG其他结构体中也有这个字段，但是根据我的经验，只有AVStream中的time_base是可用的。PTS*time_base=真正的时间</li>
<li>int64_t duration：该视频/音频流长度</li>
<li>AVDictionary *metadata：元数据信息</li>
<li>AVRational avg_frame_rate：帧率（注：对视频来说，这个挺重要的）</li>
<li>AVPacket attached_pic：附带的图片。比如说一些MP3，AAC音频文件附带的专辑封面</li>
<li>void *priv_data：关联的上下文，因为AVStream只是一个着重于媒体流的共性。</li>
</ul>
<p><strong>音视频数据流简单流程，由AVIOContext(URLContext/URLProtocol)表示的广义输入文件，在AVStream提供的特定文件容器流信息的指引下，用AVInputFormat(AVFormatContext)的接口函数读取完整一帧数据，</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://solasky.info/2016/06/30/ffmpeg学习一/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="sola_sky">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://imgsrc.baidu.com/forum/w%3D580/sign=209cc278b019ebc4c0787691b227cf79/9ec6b93eb13533fadb266e33abd3fd1f41345b3d.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Li's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Li's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/30/ffmpeg学习一/" itemprop="url">
                  ffmpeg学习一
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-30T07:12:50+08:00">
                2016-06-30
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>av_find_stream_info()</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int av_find_stream_info(AVFromatContext *ic)</div><div class="line">读取媒体文件的包来来获取信息。这对于没有头信息的文件来说是非常有用的，比如MPEG。</div><div class="line">以防止MPEG-2的重复帧模式，该函数也用于计算真正的帧率。</div><div class="line">返回大于等于0是OK的。</div></pre></td></tr></table></figure>
<p><strong>avcodec_find_decoder()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">AVCodec *<span class="title">avcodec_find_decoder</span><span class="params">(<span class="keyword">enum</span> CodecID id)</span></span></div></pre></td></tr></table></figure>
<p>通过code ID来查找一个寂静注册的解码器。查找解码器之前,必须先调用av_register_all注册所有支持的解码器</p>
<p><strong>avcodec_find_decoder_by_name()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">AVCodec *<span class="title">avcodec_find_decoder_by_name</span><span class="params">(constchar *name)</span></span></div></pre></td></tr></table></figure>
<p>通过一个指定的名称查找一个已经注册的音视频解码器。音视频解码器保存在一个链表中,查找过程中,函数从头到尾遍历链表,通过比较解码器的name来查找。查找解码器之前,必须先调用av_register_all注册所有支持的解码器。</p>
<p><strong>avcodec_find_encoder()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">AVCodec *<span class="title">avcodec_find_encoder</span><span class="params">(<span class="keyword">enum</span> CodecID id)</span></span></div></pre></td></tr></table></figure>
<p>通过code ID查找一个已经注册的音视频编码器。查找编码器之前,必须先调用av_register_all注册所有支持的编码器。</p>
<p><strong>avcodec_find_encoder_by_name()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">AVCodec *<span class="title">avcodec_find_encoder_by_name</span><span class="params">(constchar *name)</span></span></div></pre></td></tr></table></figure>
<p>通过一个指定的名称查找一个已经注册的音视频编码器。查找编码器之前,必须先调用av_register_all注册所有支持的编码器。</p>
<p><strong>avcodec_open()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_open</span><span class="params">(AVCodecContext *avctx, AVCodec *codec)</span></span></div></pre></td></tr></table></figure>
<p>使用给定的AVCodec初始化AVCodecContext。成功返回0，失败负数。</p>
<p><strong>av_guess_format()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">AVOutputFormat *<span class="title">av_guess_format</span><span class="params">(constchar *short_name,</span></span></div><div class="line">                                constchar *filename,</div><div class="line">                                constchar *mime_type)</div></pre></td></tr></table></figure>
<p>返回一个已经注册的最合适的输出格式</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://solasky.info/2016/06/28/音视频——YUV和RGB/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="sola_sky">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://imgsrc.baidu.com/forum/w%3D580/sign=209cc278b019ebc4c0787691b227cf79/9ec6b93eb13533fadb266e33abd3fd1f41345b3d.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Li's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Li's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/28/音视频——YUV和RGB/" itemprop="url">
                  音视频——YUV和RGB
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-28T19:34:02+08:00">
                2016-06-28
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="YUV"><a href="#YUV" class="headerlink" title="YUV"></a>YUV</h3><ul>
<li>如果想把YUV格式像素数据变成灰度图像，只需要将U、V分量设置成128即可。这是因为U、V是图像中的经过偏置处理的色度分量。色度分量在偏置处理前的取值范围是-128至127，这时候的无色对应的是“0”值。经过偏置后色度分量取值变成了0至255，因而此时的无色对应的就是128了。</li>
<li>如果打算将图像的亮度减半，只要将图像的每个像素的Y值取出来分别进行除以2的工作就可以了。</li>
<li>PSNR,PSNR取值通常情况下都在20-50的范围内，取值越高，代表两张图像越接近，反映出受损图像质量越好。公式如下：<br><img src="http://d.hiphotos.baidu.com/baike/pic/item/b2de9c82d158ccbf4fbf06be19d8bc3eb1354136.jpg" alt=""></li>
</ul>
<p><img src="http://img.blog.csdn.net/20160117233543104" alt=""></p>
<h4 id="YUV420P"><a href="#YUV420P" class="headerlink" title="YUV420P"></a>YUV420P</h4><ul>
<li>一帧YUV420P像素数据一共占用w*h*3/2 Byte的数据。其中前w*h Byte存储Y，接着的w*h*1/4 Byte存储U，最后w*h*1/4 Byte存储V</li>
</ul>
<h4 id="YUV444P"><a href="#YUV444P" class="headerlink" title="YUV444P"></a>YUV444P</h4><ul>
<li>如果视频帧的宽和高分别为w和h，那么一帧YUV444P像素数据一共占用w*h*3 Byte的数据。其中前w*h Byte存储Y，接着的w*h Byte存储U，最后w*h Byte存储V。</li>
</ul>
<h3 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h3><h4 id="RGB24"><a href="#RGB24" class="headerlink" title="RGB24"></a>RGB24</h4><ul>
<li>与YUV420P三个分量分开存储不同，RGB24格式的每个像素的三个分量是连续存储的。一帧宽高分别为w、h的RGB24图像一共占用w<em>h</em>3 Byte的存储空间。RGB24格式规定首先存储第一个像素的R、G、B，然后存储第二个像素的R、G、B…以此类推。类似于YUV420P的存储方式称为Planar方式，而类似于RGB24的存储方式称为Packed方式。</li>
</ul>
<h4 id="将RGB24格式像素数据封装为BMP图像"><a href="#将RGB24格式像素数据封装为BMP图像" class="headerlink" title="将RGB24格式像素数据封装为BMP图像"></a>将RGB24格式像素数据封装为BMP图像</h4><p>BMP storage pixel data in opposite direction of Y-axis (from bottom to top).  </p>
<p>在将RGB24格式像素数据封装成BMP图像主要完成了两个工作：</p>
<ol>
<li>将RGB数据前面加上文件头。</li>
<li>将RGB数据中每个像素的“B”和“R”的位置互换。<br>BMP文件是由BITMAPFILEHEADER、BITMAPINFOHEADER、RGB像素数据共3个部分构成，它的结构如下图所示。</li>
</ol>
<p>|  BITMAPFILEHEADER  |<br>|  BITMAPINFOHEADER  |<br>|     RGB像素数据     |</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span>  <span class="keyword">struct</span>  tagBITMAPFILEHEADER  </div><div class="line">&#123;   </div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span>  bfType;       <span class="comment">//位图文件的类型，必须为BM   </span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>       bfSize;       <span class="comment">//文件大小，以字节为单位  </span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span>  bfReserverd1; <span class="comment">//位图文件保留字，必须为0   </span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span>  bfReserverd2; <span class="comment">//位图文件保留字，必须为0   </span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>       bfbfOffBits;  <span class="comment">//位图文件头到数据的偏移量，以字节为单位  </span></div><div class="line">&#125;BITMAPFILEHEADER;   </div><div class="line"><span class="keyword">typedef</span>  <span class="keyword">struct</span>  tagBITMAPINFOHEADER   </div><div class="line">&#123;   </div><div class="line"><span class="keyword">long</span> biSize;                        <span class="comment">//该结构大小，字节为单位  </span></div><div class="line"><span class="keyword">long</span>  biWidth;                     <span class="comment">//图形宽度以象素为单位  </span></div><div class="line"><span class="keyword">long</span>  biHeight;                     <span class="comment">//图形高度以象素为单位  </span></div><div class="line"><span class="keyword">short</span> <span class="keyword">int</span>  biPlanes;               <span class="comment">//目标设备的级别，必须为1   </span></div><div class="line"><span class="keyword">short</span> <span class="keyword">int</span>  biBitcount;             <span class="comment">//颜色深度，每个象素所需要的位数  </span></div><div class="line"><span class="keyword">short</span> <span class="keyword">int</span>  biCompression;        <span class="comment">//位图的压缩类型  </span></div><div class="line"><span class="keyword">long</span>  biSizeImage;              <span class="comment">//位图的大小，以字节为单位  </span></div><div class="line"><span class="keyword">long</span>  biXPelsPermeter;       <span class="comment">//位图水平分辨率，每米像素数  </span></div><div class="line"><span class="keyword">long</span>  biYPelsPermeter;       <span class="comment">//位图垂直分辨率，每米像素数  </span></div><div class="line"><span class="keyword">long</span>  biClrUsed;            <span class="comment">//位图实际使用的颜色表中的颜色数  </span></div><div class="line"><span class="keyword">long</span>  biClrImportant;       <span class="comment">//位图显示过程中重要的颜色数  </span></div><div class="line">&#125;BITMAPINFOHEADER;</div></pre></td></tr></table></figure>
<p>BMP采用的是小端（Little Endian）存储方式。这种存储方式中“RGB24”格式的像素的分量存储的先后顺序为B、G、R。由于RGB24格式存储的顺序是R、G、B，所以需要将“R”和“B”顺序作一个调换再进行存储。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://solasky.info/2016/06/22/SurfaceView学习记录/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="sola_sky">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://imgsrc.baidu.com/forum/w%3D580/sign=209cc278b019ebc4c0787691b227cf79/9ec6b93eb13533fadb266e33abd3fd1f41345b3d.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Li's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Li's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/22/SurfaceView学习记录/" itemprop="url">
                  SurfaceView学习记录
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-22T19:03:03+08:00">
                2016-06-22
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://blog.csdn.net/luoshengyang/article/details/8661317" target="_blank" rel="external">原文出处：SurfaceView，老罗的文章</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onAttachedToWindow</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>.onAttachedToWindow();  </div><div class="line">    mParent.requestTransparentRegion(<span class="keyword">this</span>);  </div><div class="line">    mSession = getWindowSession();  </div><div class="line">    ......  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一件事情是通知父视图，当前正在处理的SurfaceView需要在宿主窗口的绘图表面上挖一个洞，即需要在宿主窗口的绘图表面上设置一块透明区域。当前正在处理的SurfaceView的父视图保存在父类View的成员变量mParent中，通过调用这个成员变量mParent所指向的一个ViewGroup对象的成员函数requestTransparentRegion，就可以通知到当前正在处理的SurfaceView的父视图，当前正在处理的SurfaceView需要在宿主窗口的绘图表面上设置一块透明区域。</p>
<p>第二件事情是调用从父类View继承下来的成员函数getWindowSession来获得一个实现了IWindowSession接口的Binder代理对象，并且将该Binder代理对象保存在SurfaceView类的成员变量mSession中。从前面Android应用程序窗口（Activity）实现框架简要介绍和学习计划这个系列的文章可以知道，在Android系统中，每一个应用程序进程都有一个实现了IWindowSession接口的Binder代理对象，这个Binder代理对象是用来与WindowManagerService服务进行通信的，View类的成员函数getWindowSession返回的就是该Binder代理对象。在接下来的Step 8中，我们就可以看到，SurfaceView就可以通过这个实现了IWindowSession接口的Binder代理对象来请求WindowManagerService服务为自己创建绘图表面的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class SurfaceView extends View &#123;  </div><div class="line">    ......  </div><div class="line">  </div><div class="line">    boolean mRequestedVisible = false;  </div><div class="line">    boolean mWindowVisibility = false;  </div><div class="line">    boolean mViewVisibility = false;  </div><div class="line">    .....  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    protected void onWindowVisibilityChanged(int visibility) &#123;  </div><div class="line">        super.onWindowVisibilityChanged(visibility);  </div><div class="line">        mWindowVisibility = visibility == VISIBLE;  </div><div class="line">        mRequestedVisible = mWindowVisibility &amp;&amp; mViewVisibility;  </div><div class="line">        updateWindow(false, false);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    ......  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> SurfaceView类有三个用来描述可见性的成员变量mRequestedVisible、mWindowVisibility和mViewVisibility。其中，mWindowVisibility表示SurfaceView的宿主窗口的可见性，mViewVisibility表示SurfaceView自身的可见性。只有当mWindowVisibility和mViewVisibility的值均等于true的时候，mRequestedVisible的值才为true，表示SurfaceView是可见的。</p>
<p>绘图表面类型为SURFACE_TYPE_PUSH_BUFFERS的SurfaceView的UI是不能由应用程序来控制的，而是由专门的服务来控制的，例如，摄像头服务或者视频播放服务，同时，SurfaceFlinger服务会使用一种特殊的LayerBuffer来描述这种绘图表面。使用LayerBuffer来描述的绘图表面在进行渲染的时候，可以使用硬件加速，例如，使用copybit或者overlay来加快渲染速度，从而可以获得更流畅的摄像头预览或者视频播放。</p>
<ul>
<li>mHaveFrame，用来描述SurfaceView的宿主窗口的大小是否已经计算好了。只有当宿主窗口的大小计算之后，SurfaceView才可以更新自己的窗口。</li>
<li><p>mRequestedWidth，用来描述SurfaceView最后一次被请求的宽度。</p>
</li>
<li><p>mRequestedHeight，用来描述SurfaceView最后一次被请求的高度。</p>
</li>
<li><p>mRequestedFormat，用来描述SurfaceView最后一次被请求的绘图表面的像素格式。</p>
</li>
<li><p>mNewSurfaceNeeded，用来描述SurfaceView是否需要新创建一个绘图表面。</p>
</li>
<li><p>mLeft、mTop、mWidth、mHeight，用来描述SurfaceView上一次所在的位置以及大小。</p>
</li>
<li><p>mFormat，用来描述SurfaceView的绘图表面上一次所设置的格式。</p>
</li>
<li><p>mVisible，用来描述SurfaceView上一次被设置的可见性。</p>
</li>
<li><p>mType，用来描述SurfaceView的绘图表面上一次所设置的类型。</p>
</li>
<li><p>mUpdateWindowNeeded，用来描述SurfaceView是否被WindowManagerService服务通知执行一次UI更新操作。</p>
</li>
<li><p>mReportDrawNeeded，用来描述SurfaceView是否被WindowManagerService服务通知执行一次UI绘制操作。</p>
</li>
<li><p>mLayout，指向的是一个WindowManager.LayoutParams对象，用来传递SurfaceView的布局参数以及属性值给WindowManagerService服务，以便WindowManagerService服务可以正确地维护它的状态。</p>
</li>
</ul>
<h3 id="挖洞过程"><a href="#挖洞过程" class="headerlink" title="挖洞过程"></a>挖洞过程</h3><p>从SurfaceView的绘图表面的创建过程可以知道，SurfaceView在被附加到宿主窗口之上的时候，SurfaceView类的成员函数onAttachedToWindow就会被调用。SurfaceView类的成员函数onAttachedToWindow在被调用的期间，就会请求在宿主窗口上设置透明区域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class SurfaceView extends View &#123;  </div><div class="line">    ......  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    protected void onAttachedToWindow() &#123;  </div><div class="line">        super.onAttachedToWindow();  </div><div class="line">        mParent.requestTransparentRegion(this);  </div><div class="line">        ......  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    ......  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewGroup</span> <span class="keyword">extends</span> <span class="title">View</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>, <span class="title">ViewManager</span> </span>&#123;  </div><div class="line">    ......  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestTransparentRegion</span><span class="params">(View child)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;  </div><div class="line">            child.mPrivateFlags |= View.REQUEST_TRANSPARENT_REGIONS;  </div><div class="line">            <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;  </div><div class="line">                mParent.requestTransparentRegion(<span class="keyword">this</span>);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    ......  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRoot</span> <span class="keyword">extends</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>,  </span></div><div class="line">        <span class="title">View</span>.<span class="title">AttachInfo</span>.<span class="title">Callbacks</span> &#123;  </div><div class="line">    ......  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestTransparentRegion</span><span class="params">(View child)</span> </span>&#123;  </div><div class="line">        <span class="comment">// the test below should not fail unless someone is messing with us  </span></div><div class="line">        checkThread();  </div><div class="line">        <span class="keyword">if</span> (mView == child) &#123;  </div><div class="line">            mView.mPrivateFlags |= View.REQUEST_TRANSPARENT_REGIONS;  </div><div class="line">            <span class="comment">// Need to make sure we re-evaluate the window attributes next  </span></div><div class="line">            <span class="comment">// time around, to ensure the window has the correct format.  </span></div><div class="line">            mWindowAttributesChanged = <span class="keyword">true</span>;  </div><div class="line">            requestLayout();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    ......  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当一个窗口被请求设置了一块透明区域之后，它的窗口属性就发生变化了，因此，这时候除了要将与它所关联的一个ViewRoot对象的成员变量mWindowAttributesChanged的值设置为true之外，还要调用该ViewRoot对象的成员函数requestLayout来请求刷新一下窗口的UI，即请求对窗口的UI进行重新布局和绘制。<br>ViewRoot类的成员函数requestLayout最终会调用到另外一个成员函数performTraversals来实际执行刷新窗口UI的操作。<br>ViewRoot类的成员函数performTraversals在刷新窗口UI的过程中，就会将嵌入在它里面的SurfaceView所要设置的透明区域收集起来，以便可以请求WindowManagerService将这块透明区域设置到它的绘图表面上去。<br><strong>挖洞过程主要是使用Region，从顶层视图将其往子View传递Region，在传递过程中通过调用Region的op()方法，将某区域设置为Region.Op.DIFFERENCE或者为Region.Op.UNION来区分是否将其透明，前者不透明，后者透明处理(sWindowSession.setTransparentRegion()方法将UNION的区域设置)</strong></p>
<h3 id="绘制过程"><a href="#绘制过程" class="headerlink" title="绘制过程"></a>绘制过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class SurfaceView extends View &#123;  </div><div class="line">    ......  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    public void draw(Canvas canvas) &#123;  </div><div class="line">        if (mWindowType != WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) &#123;  </div><div class="line">            // draw() is not called when SKIP_DRAW is set  </div><div class="line">            if ((mPrivateFlags &amp; SKIP_DRAW) == 0) &#123;  </div><div class="line">                // punch a whole in the view-hierarchy below us  </div><div class="line">                canvas.drawColor(0, PorterDuff.Mode.CLEAR);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        super.draw(canvas);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    protected void dispatchDraw(Canvas canvas) &#123;  </div><div class="line">        if (mWindowType != WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) &#123;  </div><div class="line">            // if SKIP_DRAW is cleared, draw() has already punched a hole  </div><div class="line">            if ((mPrivateFlags &amp; SKIP_DRAW) == SKIP_DRAW) &#123;  </div><div class="line">                // punch a whole in the view-hierarchy below us  </div><div class="line">                canvas.drawColor(0, PorterDuff.Mode.CLEAR);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        // reposition ourselves where the surface is   </div><div class="line">        mHaveFrame = true;  </div><div class="line">        updateWindow(false, false);  </div><div class="line">        super.dispatchDraw(canvas);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    ......  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>本来SurfaceView类的成员函数draw是用来将自己的UI绘制在宿主窗口的绘图表面上的，但是这里我们可以看到，如果当前正在处理的SurfaceView不是用作宿主窗口面板的时候，即其成员变量mWindowType的值不等于WindowManager.LayoutParams.TYPE_APPLICATION_PANEL的时候，SurfaceView类的成员函数draw只是简单地将它所占据的区域绘制为黑色。<br>本来SurfaceView类的成员函数dispatchDraw是用来绘制SurfaceView的子视图的，但是这里我们同样看到，如果当前正在处理的SurfaceView不是用作宿主窗口面板的时候，那么SurfaceView类的成员函数dispatchDraw只是简单地将它所占据的区域绘制为黑色，同时，它还会通过调用另外一个成员函数updateWindow更新自己的UI，实际上就是请求WindowManagerService服务对自己的UI进行布局，以及创建绘图表面。<br>从SurfaceView类的成员函数draw和dispatchDraw的实现就可以看出，SurfaceView在其宿主窗口的绘图表面上面所做的操作就是将自己所占据的区域绘为黑色，除此之外，就没有其它更多的操作了，这是因为SurfaceView的UI是要展现在它自己的绘图表面上面的。接下来我们就分析如何在SurfaceView的绘图表面上面进行UI绘制。<br>注意，只有在一个SurfaceView的绘图表面的类型不是SURFACE_TYPE_PUSH_BUFFERS的时候，我们才可以自由地在上面绘制UI。</p>
<p>在<code>SurfaceViewHolder.lockCanvas()</code>其内部实现时，在成功获取画布时，是调用了一个域来对画布进行锁定的。 <code>final ReentrantLock mSurfaceLock = new ReentrantLock();</code><br>具体代码如下:</p>
<pre><code>public class SurfaceView extends View {  
    ......  

    final ReentrantLock mSurfaceLock = new ReentrantLock();  
    final Surface mSurface = new Surface();  
    ......  

    private SurfaceHolder mSurfaceHolder = new SurfaceHolder() {  
        ......  

        public Canvas lockCanvas() {  
            return internalLockCanvas(null);  
        }  

        ......  

        private final Canvas internalLockCanvas(Rect dirty) {  
            if (mType == SURFACE_TYPE_PUSH_BUFFERS) {  
                throw new BadSurfaceTypeException(  
                        &quot;Surface type is SURFACE_TYPE_PUSH_BUFFERS&quot;);  
            }  
            mSurfaceLock.lock();  
            ......  

            Canvas c = null;  
            if (!mDrawingStopped &amp;&amp; mWindow != null) {  
                Rect frame = dirty != null ? dirty : mSurfaceFrame;  
                try {  
                    c = mSurface.lockCanvas(frame);  
                } catch (Exception e) {  
                    Log.e(LOG_TAG, &quot;Exception locking surface&quot;, e);  
                }  
            }  
            ......  

            if (c != null) {  
                mLastLockTime = SystemClock.uptimeMillis();  
                return c;  
            }  
            ......  

            mSurfaceLock.unlock();  

            return null;    
        }   

        ......           
    }  

    ......  
}
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SurfaceView有以下三个特点：</p>
<ul>
<li>具有独立的绘图表面；</li>
<li>需要在宿主窗口上挖一个洞来显示自己；</li>
<li>它的UI绘制可以在独立的线程中进行，这样就可以进行复杂的UI绘制，并且不会影响应用程序的主线程响应用户输入。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://solasky.info/2016/06/21/View之绘制过程/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="sola_sky">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://imgsrc.baidu.com/forum/w%3D580/sign=209cc278b019ebc4c0787691b227cf79/9ec6b93eb13533fadb266e33abd3fd1f41345b3d.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Li's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Li's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/21/View之绘制过程/" itemprop="url">
                  View之绘制过程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-21T07:36:13+08:00">
                2016-06-21
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="View-onMeasure"><a href="#View-onMeasure" class="headerlink" title="View onMeasure()"></a>View onMeasure()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">     setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">             getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>onMeasure默认的实现仅仅调用了setMeasuredDimension，setMeasuredDimension函数是一个很关键的函数，它对View的成员变量mMeasuredWidth和mMeasuredHeight变量赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> result = size;</div><div class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">        result = size;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">        result = specSize;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果specMode为AT_MOST或EXACTLY，则返回的尺寸就是specSize，而一般系统默认规格都是这两个，所以就知道为什么一般我们在给控件设置<code>layout_width和layout_height</code>时，控件会填充整个剩余空间了。</p>
<h3 id="ViewGroup"><a href="#ViewGroup" class="headerlink" title="ViewGroup"></a>ViewGroup</h3><h4 id="measureChildren"><a href="#measureChildren" class="headerlink" title="measureChildren"></a>measureChildren</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</div><div class="line">    <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</div><div class="line">        <span class="keyword">final</span> View child = children[i];</div><div class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</div><div class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到，<code>measureChildren()</code>方法就是对自己的子view循环调用<code>measureChild</code>。那我们接下来看看这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></div><div class="line">        <span class="keyword">int</span> parentHeightMeasureSpec) &#123;</div><div class="line">    <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">            mPaddingLeft + mPaddingRight, lp.width);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">            mPaddingTop + mPaddingBottom, lp.height);</div><div class="line"></div><div class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>里面最主要的方法是将父类传进来的MeasureSpec封装成childMeasureSpec，然后调用子view的<code>measure()</code>并将childMeasureSpec传入，而<code>measure()</code>会调用<code>onMeasure()</code>。<br>那么我们看看<code>getChildMeasureSpec()</code>是如何实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</div><div class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> resultMode = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">    <span class="comment">// Parent has imposed an exact size on us</span></div><div class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">            resultSize = childDimension;</div><div class="line">            resultMode = MeasureSpec.EXACTLY;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">            <span class="comment">// Child wants to be our size. So be it.</span></div><div class="line">            resultSize = size;</div><div class="line">            resultMode = MeasureSpec.EXACTLY;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">            <span class="comment">// Child wants to determine its own size. It can't be</span></div><div class="line">            <span class="comment">// bigger than us.</span></div><div class="line">            resultSize = size;</div><div class="line">            resultMode = MeasureSpec.AT_MOST;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Parent has imposed a maximum size on us</span></div><div class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// Child wants a specific size... so be it</span></div><div class="line">            resultSize = childDimension;</div><div class="line">            resultMode = MeasureSpec.EXACTLY;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">            <span class="comment">// Child wants to be our size, but our size is not fixed.</span></div><div class="line">            <span class="comment">// Constrain child to not be bigger than us.</span></div><div class="line">            resultSize = size;</div><div class="line">            resultMode = MeasureSpec.AT_MOST;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">            <span class="comment">// Child wants to determine its own size. It can't be</span></div><div class="line">            <span class="comment">// bigger than us.</span></div><div class="line">            resultSize = size;</div><div class="line">            resultMode = MeasureSpec.AT_MOST;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Parent asked to see how big we want to be</span></div><div class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// Child wants a specific size... let him have it</span></div><div class="line">            resultSize = childDimension;</div><div class="line">            resultMode = MeasureSpec.EXACTLY;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">            <span class="comment">// Child wants to be our size... find out how big it should</span></div><div class="line">            <span class="comment">// be</span></div><div class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">            resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">            <span class="comment">// Child wants to determine its own size.... find out how</span></div><div class="line">            <span class="comment">// big it should be</span></div><div class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">            resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当从父View传进来的模式是EXACTLY时，若子view尺寸不是MATCH_PARENT或WRAP_CONTENT时，则resultSize等于给定的尺寸，模式也是EXACTLY。若是MATCH_PARENT时，resultSize是父View给予的尺寸，模式也是EXACTLY。WRAP_CONTENT时，模式改成AT_MOST。</li>
<li>父View传进来的是AT_MOST时，子view若尺寸给定，则resultSize等于给定尺寸，模式变为EXACTLY。若是MATCH_PARENT或WRAP_CONTENT时，则尺寸是父View的，模式是AT_MOST。即使子View为MATCH_PARENT时，由于父View的尺寸不固定，所以 Constrain child to not be bigger than us。</li>
<li>当为UNSPECIFIED时，给定尺寸时，结果同上面一样。若为另外两种情况，模式都是UNSPECIFIED，尺寸的话得根据android版本，若小于M版，则为0，否则为父View的尺寸。</li>
</ul>
<p>如果其本身包含子视图，则计算出来的measureSpec将作为调用其子视图measure函数的参数，同时也作为自身调用setMeasuredDimension的参数，如果其不包含子视图则默认情况下最终会调用onMeasure的默认实现，并最终调用到setMeasuredDimension。</p>
<h3 id="View-layout"><a href="#View-layout" class="headerlink" title="View layout"></a>View layout</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line"></div><div class="line">......</div><div class="line"></div><div class="line">      <span class="keyword">int</span> oldL = mLeft;</div><div class="line">      <span class="keyword">int</span> oldT = mTop;</div><div class="line">      <span class="keyword">int</span> oldB = mBottom;</div><div class="line">      <span class="keyword">int</span> oldR = mRight;</div><div class="line"></div><div class="line">      <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</div><div class="line">              setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">          onLayout(changed, l, t, r, b);</div><div class="line">          mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class="line"></div><div class="line">          ListenerInfo li = mListenerInfo;</div><div class="line">          <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</div><div class="line">              ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">                      (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</div><div class="line">              <span class="keyword">int</span> numListeners = listenersCopy.size();</div><div class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</div><div class="line">                  listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</div><div class="line">      mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>主要是判断位置是否发生变化和是否被要求重绘，是的话就调用onLayout(),并且通知布局发生变化。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://imgsrc.baidu.com/forum/w%3D580/sign=209cc278b019ebc4c0787691b227cf79/9ec6b93eb13533fadb266e33abd3fd1f41345b3d.jpg"
               alt="sola_sky" />
          <p class="site-author-name" itemprop="name">sola_sky</p>
          <p class="site-description motion-element" itemprop="description">学习记录和总结</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">categories</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  Sat May 21 2016 08:00:00 GMT+0800 (中国标准时间) - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sola_sky</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  




  
  

  

  

  

  


</body>
</html>
